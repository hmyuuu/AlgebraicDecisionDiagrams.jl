var documenterSearchIndex = {"docs":
[{"location":"guide/zdds/#Zero-suppressed-Decision-Diagrams-(ZDDs)","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Zero-suppressed Decision Diagrams (ZDDs) are a variant of BDDs optimized for representing sparse sets and combinatorial objects. They are particularly efficient for set families where most elements are absent.","category":"page"},{"location":"guide/zdds/#What-are-ZDDs?","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"What are ZDDs?","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"ZDDs differ from BDDs in their reduction rule:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"BDD reduction: If both children are the same, eliminate the node\nZDD reduction: If the then-child is empty (⊥), eliminate the node and return the else-child","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"This makes ZDDs ideal for:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Sparse set families\nCombinatorial structures (paths, cuts, matchings)\nPower set operations\nConstraint satisfaction problems","category":"page"},{"location":"guide/zdds/#Creating-ZDDs","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Creating ZDDs","text":"","category":"section"},{"location":"guide/zdds/#Empty-Set-and-Base-Set","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Empty Set and Base Set","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"using AlgebraicDecisionDiagrams\n\nmgr = DDManager(5)\n\n# Empty family: ∅\nempty = mgr.zero\n\n# Family containing only the empty set: {∅}\nbase = mgr.one","category":"page"},{"location":"guide/zdds/#Singletons","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Singletons","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Create a family containing a single element:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(5)\n\n# Family containing {1}: {{1}}\ns1 = zdd_singleton(mgr, 1)\n\n# Family containing {2}: {{2}}\ns2 = zdd_singleton(mgr, 2)\n\n# Family containing {5}: {{5}}\ns5 = zdd_singleton(mgr, 5)","category":"page"},{"location":"guide/zdds/#From-Sets","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"From Sets","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Create a ZDD from a collection of sets:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(4)\n\n# Family of sets: {{1, 2}, {2, 3}, {1, 3}, {4}}\nsets = [\n    [1, 2],\n    [2, 3],\n    [1, 3],\n    [4]\n]\n\nfamily = zdd_from_sets(mgr, sets)\n\n# Count sets in family\ncount = zdd_count(mgr, family)  # 4\n\n# Convert back to sets\nrecovered = zdd_to_sets(mgr, family)\nprintln(recovered)  # [[1, 2], [2, 3], [1, 3], [4]]","category":"page"},{"location":"guide/zdds/#Set-Operations","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Set Operations","text":"","category":"section"},{"location":"guide/zdds/#Union","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Union","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Union of two set families:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(3)\n\n# F1 = {{1}, {2}}\ns1 = zdd_singleton(mgr, 1)\ns2 = zdd_singleton(mgr, 2)\nf1 = zdd_union(mgr, s1, s2)\n\n# F2 = {{2}, {3}}\ns3 = zdd_singleton(mgr, 3)\nf2 = zdd_union(mgr, s2, s3)\n\n# F1 ∪ F2 = {{1}, {2}, {3}}\nunion = zdd_union(mgr, f1, f2)\n\nsets = zdd_to_sets(mgr, union)\nprintln(sets)  # [[1], [2], [3]]","category":"page"},{"location":"guide/zdds/#Intersection","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Intersection","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Intersection of two set families:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(3)\n\n# F1 = {{1}, {2}}\ns1 = zdd_singleton(mgr, 1)\ns2 = zdd_singleton(mgr, 2)\nf1 = zdd_union(mgr, s1, s2)\n\n# F2 = {{2}, {3}}\ns3 = zdd_singleton(mgr, 3)\nf2 = zdd_union(mgr, s2, s3)\n\n# F1 ∩ F2 = {{2}}\nintersection = zdd_intersection(mgr, f1, f2)\n\nsets = zdd_to_sets(mgr, intersection)\nprintln(sets)  # [[2]]","category":"page"},{"location":"guide/zdds/#Difference","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Difference","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Set difference:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(3)\n\n# F1 = {{1}, {2}, {3}}\ns1 = zdd_singleton(mgr, 1)\ns2 = zdd_singleton(mgr, 2)\ns3 = zdd_singleton(mgr, 3)\nf1 = zdd_union(mgr, zdd_union(mgr, s1, s2), s3)\n\n# F2 = {{2}}\nf2 = s2\n\n# F1 \\ F2 = {{1}, {3}}\ndifference = zdd_difference(mgr, f1, f2)\n\nsets = zdd_to_sets(mgr, difference)\nprintln(sets)  # [[1], [3]]","category":"page"},{"location":"guide/zdds/#Product-(Cartesian-Product)","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Product (Cartesian Product)","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Cartesian product of set families:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(4)\n\n# F1 = {{1}, {2}}\ns1 = zdd_singleton(mgr, 1)\ns2 = zdd_singleton(mgr, 2)\nf1 = zdd_union(mgr, s1, s2)\n\n# F2 = {{3}, {4}}\ns3 = zdd_singleton(mgr, 3)\ns4 = zdd_singleton(mgr, 4)\nf2 = zdd_union(mgr, s3, s4)\n\n# F1 × F2 = {{1,3}, {1,4}, {2,3}, {2,4}}\nproduct = zdd_product(mgr, f1, f2)\n\nsets = zdd_to_sets(mgr, product)\nprintln(sets)  # [[1,3], [1,4], [2,3], [2,4]]","category":"page"},{"location":"guide/zdds/#Counting","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Counting","text":"","category":"section"},{"location":"guide/zdds/#Count-Sets","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Count Sets","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Count the number of sets in a family:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(4)\n\nsets = [[1, 2], [2, 3], [1, 3], [4]]\nfamily = zdd_from_sets(mgr, sets)\n\ncount = zdd_count(mgr, family)\nprintln(\"Number of sets: \", count)  # 4","category":"page"},{"location":"guide/zdds/#Count-Nodes","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Count Nodes","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Count nodes in the ZDD:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(4)\n\nsets = [[1, 2], [2, 3], [1, 3], [4]]\nfamily = zdd_from_sets(mgr, sets)\n\nnodes = count_nodes(mgr, family)\nprintln(\"Number of nodes: \", nodes)","category":"page"},{"location":"guide/zdds/#Converting-Between-BDDs-and-ZDDs","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Converting Between BDDs and ZDDs","text":"","category":"section"},{"location":"guide/zdds/#BDD-to-ZDD","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"BDD to ZDD","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Convert a BDD to a ZDD (characteristic function to set family):","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(3)\n\n# BDD: x1 ∧ x2 (true when both x1 and x2 are true)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nbdd = bdd_and(mgr, x1, x2)\n\n# Convert to ZDD: family of sets where x1 and x2 are present\nzdd = bdd_to_zdd(mgr, bdd)\n\n# Should contain sets with both 1 and 2\nsets = zdd_to_sets(mgr, zdd)\nprintln(sets)  # [[1, 2], [1, 2, 3]]","category":"page"},{"location":"guide/zdds/#ZDD-to-BDD","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"ZDD to BDD","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Convert a ZDD to a BDD:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(3)\n\n# ZDD: {{1, 2}}\ns1 = zdd_singleton(mgr, 1)\ns2 = zdd_singleton(mgr, 2)\nzdd = zdd_product(mgr, s1, s2)\n\n# Convert to BDD\nbdd = zdd_to_bdd(mgr, zdd)\n\n# BDD should be true when x1=1, x2=1, x3=0\nassignment = Dict(1 => true, 2 => true, 3 => false)\nresult = bdd_eval(mgr, bdd, assignment)\nprintln(result)  # true","category":"page"},{"location":"guide/zdds/#Applications","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Applications","text":"","category":"section"},{"location":"guide/zdds/#Power-Set","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Power Set","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Generate all subsets of a set:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(3)\n\n# Start with {∅}\nresult = mgr.one\n\n# Add each element optionally\nfor i in 1:3\n    singleton = zdd_singleton(mgr, i)\n    # For each existing set, add version with and without element i\n    with_i = zdd_product(mgr, result, singleton)\n    result = zdd_union(mgr, result, with_i)\nend\n\n# Result: all subsets of {1, 2, 3}\nsets = zdd_to_sets(mgr, result)\nprintln(\"Power set: \", sets)\n# [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]","category":"page"},{"location":"guide/zdds/#Combinations","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Combinations","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Generate all k-combinations:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(5)\n\n# Generate all 3-combinations of {1, 2, 3, 4, 5}\nfunction combinations(mgr, n, k)\n    if k == 0\n        return mgr.one  # {∅}\n    end\n    if k > n\n        return mgr.zero  # ∅\n    end\n\n    # Recursive: combinations with element n, or without\n    with_n = zdd_product(mgr,\n        combinations(mgr, n-1, k-1),\n        zdd_singleton(mgr, n))\n    without_n = combinations(mgr, n-1, k)\n\n    return zdd_union(mgr, with_n, without_n)\nend\n\nc_3_5 = combinations(mgr, 5, 3)\nsets = zdd_to_sets(mgr, c_3_5)\nprintln(\"3-combinations of {1,2,3,4,5}: \", length(sets))  # 10","category":"page"},{"location":"guide/zdds/#Graph-Paths","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Graph Paths","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Represent all paths in a graph:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(6)\n\n# Graph edges: 1-2, 2-3, 1-3, 3-4, 2-4\n# Represent each edge as a number\nedges = Dict(\n    (1,2) => 1,\n    (2,3) => 2,\n    (1,3) => 3,\n    (3,4) => 4,\n    (2,4) => 5\n)\n\n# Paths from 1 to 4:\n# Path 1: 1->2->4 (edges 1, 5)\npath1 = zdd_product(mgr,\n    zdd_singleton(mgr, edges[(1,2)]),\n    zdd_singleton(mgr, edges[(2,4)]))\n\n# Path 2: 1->3->4 (edges 3, 4)\npath2 = zdd_product(mgr,\n    zdd_singleton(mgr, edges[(1,3)]),\n    zdd_singleton(mgr, edges[(3,4)]))\n\n# Path 3: 1->2->3->4 (edges 1, 2, 4)\npath3 = zdd_product(mgr,\n    zdd_product(mgr,\n        zdd_singleton(mgr, edges[(1,2)]),\n        zdd_singleton(mgr, edges[(2,3)])),\n    zdd_singleton(mgr, edges[(3,4)]))\n\n# All paths\nall_paths = zdd_union(mgr, zdd_union(mgr, path1, path2), path3)\n\npaths = zdd_to_sets(mgr, all_paths)\nprintln(\"Paths from 1 to 4: \", paths)","category":"page"},{"location":"guide/zdds/#Constraint-Satisfaction","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Constraint Satisfaction","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Represent solutions to constraints:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(4)\n\n# Variables: x1, x2, x3, x4\n# Constraint 1: At least one of x1, x2 must be selected\n# Constraint 2: If x1 is selected, x3 must be selected\n# Constraint 3: x2 and x4 cannot both be selected\n\n# Start with all possible subsets\nall_subsets = mgr.one\nfor i in 1:4\n    singleton = zdd_singleton(mgr, i)\n    with_i = zdd_product(mgr, all_subsets, singleton)\n    all_subsets = zdd_union(mgr, all_subsets, with_i)\nend\n\n# Apply constraints by filtering\n# (This is a simplified example - real implementation would be more efficient)\n\nsolutions = zdd_to_sets(mgr, all_subsets)\n\n# Filter: at least one of x1, x2\nsolutions = filter(s -> 1 in s || 2 in s, solutions)\n\n# Filter: if x1 then x3\nsolutions = filter(s -> !(1 in s) || (3 in s), solutions)\n\n# Filter: not both x2 and x4\nsolutions = filter(s -> !(2 in s && 4 in s), solutions)\n\nprintln(\"Valid solutions: \", solutions)","category":"page"},{"location":"guide/zdds/#Performance-Tips","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Performance Tips","text":"","category":"section"},{"location":"guide/zdds/#1.-ZDDs-vs-BDDs-for-Sparse-Sets","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"1. ZDDs vs BDDs for Sparse Sets","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(100)\n\n# For sparse sets (few elements), ZDDs are much more efficient\nsparse_sets = [\n    [1, 50],\n    [25, 75],\n    [10, 90]\n]\n\n# ZDD: Very compact\nzdd = zdd_from_sets(mgr, sparse_sets)\nzdd_nodes = count_nodes(mgr, zdd)\n\n# BDD would be much larger for the same representation\nprintln(\"ZDD nodes: \", zdd_nodes)  # Small","category":"page"},{"location":"guide/zdds/#2.-Build-Incrementally","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"2. Build Incrementally","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(10)\n\n# Good: Build incrementally\nresult = mgr.one\nfor i in 1:10\n    singleton = zdd_singleton(mgr, i)\n    result = zdd_union(mgr, result, singleton)\nend\n\n# Result: {{1}, {2}, ..., {10}}","category":"page"},{"location":"guide/zdds/#3.-Use-Product-for-Set-Construction","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"3. Use Product for Set Construction","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(5)\n\n# Good: Use product to build sets\ns1 = zdd_singleton(mgr, 1)\ns2 = zdd_singleton(mgr, 2)\ns3 = zdd_singleton(mgr, 3)\n\n# {{1, 2, 3}}\nset_123 = zdd_product(mgr, zdd_product(mgr, s1, s2), s3)\n\n# More efficient than converting from array","category":"page"},{"location":"guide/zdds/#ZDD-Reduction-Rule","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"ZDD Reduction Rule","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Understanding the ZDD reduction rule:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"# BDD reduction: if then_child == else_child, return child\n# ZDD reduction: if then_child == ⊥ (empty), return else_child\n\n# Example: Representing {{2}}\n# Variable 1: else-child points to node for variable 2\n#            then-child would be ⊥, so node is eliminated\n# Variable 2: then-child is ⊤ (base set)\n#            else-child is ⊥ (empty)\n#            Node is kept because then-child ≠ ⊥\n\n# This makes ZDDs compact for sparse sets","category":"page"},{"location":"guide/zdds/#Common-Patterns","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Common Patterns","text":"","category":"section"},{"location":"guide/zdds/#Set-Family-Operations","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Set Family Operations","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(5)\n\n# Create families\nf1 = zdd_from_sets(mgr, [[1, 2], [3]])\nf2 = zdd_from_sets(mgr, [[2, 3], [4]])\n\n# Union: all sets from either family\nunion = zdd_union(mgr, f1, f2)\n\n# Intersection: sets in both families\nintersection = zdd_intersection(mgr, f1, f2)\n\n# Difference: sets in f1 but not f2\ndifference = zdd_difference(mgr, f1, f2)\n\n# Product: combine sets from both families\nproduct = zdd_product(mgr, f1, f2)","category":"page"},{"location":"guide/zdds/#Filtering-Sets","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Filtering Sets","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"mgr = DDManager(5)\n\n# Start with a family\nfamily = zdd_from_sets(mgr, [[1], [1, 2], [2, 3], [3, 4, 5]])\n\n# Filter: keep only sets containing element 2\ns2 = zdd_singleton(mgr, 2)\n\n# Sets containing 2 are those that intersect with {2}\n# (More complex filtering would require custom operations)\n\nsets = zdd_to_sets(mgr, family)\nfiltered = filter(s -> 2 in s, sets)\nresult = zdd_from_sets(mgr, filtered)","category":"page"},{"location":"guide/zdds/#Limitations","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Limitations","text":"","category":"section"},{"location":"guide/zdds/#No-Complement-Edges","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"No Complement Edges","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"ZDDs don't use complement edges:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"All operations must be explicit\nMay result in larger diagrams than BDDs for dense sets","category":"page"},{"location":"guide/zdds/#Element-Ordering","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Element Ordering","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Like BDDs, element ordering matters:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Different orderings can lead to different sizes\nNo dynamic reordering yet implemented","category":"page"},{"location":"guide/zdds/#Conversion-Overhead","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Conversion Overhead","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Converting between sets and ZDDs has overhead:","category":"page"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"Use native ZDD operations when possible\nAvoid repeated conversions","category":"page"},{"location":"guide/zdds/#See-Also","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"See Also","text":"","category":"section"},{"location":"guide/zdds/","page":"Zero-suppressed Decision Diagrams (ZDDs)","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"BDD Guide: Binary Decision Diagrams\nADD Guide: Algebraic Decision Diagrams\nAPI Reference: Complete API documentation","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complete API documentation for AlgebraicDecisionDiagrams.jl.","category":"page"},{"location":"api/#Manager","page":"API Reference","title":"Manager","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.DDManager","page":"API Reference","title":"AlgebraicDecisionDiagrams.DDManager","text":"DDManager\n\nMain manager for decision diagrams. Handles node allocation, unique table, computed table, and variable ordering.\n\n\n\n\n\n","category":"type"},{"location":"api/#Constructor","page":"API Reference","title":"Constructor","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"DDManager(num_vars::Int)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Create a decision diagram manager for up to num_vars variables.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"num_vars::Int: Maximum number of variables","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"DDManager: A new manager instance","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"mgr = DDManager(10)  # Manager for up to 10 variables","category":"page"},{"location":"api/#Binary-Decision-Diagrams-(BDDs)","page":"API Reference","title":"Binary Decision Diagrams (BDDs)","text":"","category":"section"},{"location":"api/#Variable-Creation","page":"API Reference","title":"Variable Creation","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.ith_var","page":"API Reference","title":"AlgebraicDecisionDiagrams.ith_var","text":"ith_var(mgr::DDManager, i::Int)\n\nCreate a BDD for the i-th variable (projection function).\n\n\n\n\n\n","category":"function"},{"location":"api/#Boolean-Operations","page":"API Reference","title":"Boolean Operations","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.bdd_and","page":"API Reference","title":"AlgebraicDecisionDiagrams.bdd_and","text":"bdd_and(mgr::DDManager, f::NodeId, g::NodeId)\n\nCompute the conjunction (AND) of two BDDs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.bdd_or","page":"API Reference","title":"AlgebraicDecisionDiagrams.bdd_or","text":"bdd_or(mgr::DDManager, f::NodeId, g::NodeId)\n\nCompute the disjunction (OR) of two BDDs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.bdd_xor","page":"API Reference","title":"AlgebraicDecisionDiagrams.bdd_xor","text":"bdd_xor(mgr::DDManager, f::NodeId, g::NodeId)\n\nCompute the exclusive-or (XOR) of two BDDs.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.bdd_not","page":"API Reference","title":"AlgebraicDecisionDiagrams.bdd_not","text":"bdd_not(mgr::DDManager, f::NodeId)\n\nCompute the negation (NOT) of a BDD. For BDDs with complement edges, this is just a pointer complement.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.bdd_ite","page":"API Reference","title":"AlgebraicDecisionDiagrams.bdd_ite","text":"bdd_ite(mgr::DDManager, f::NodeId, g::NodeId, h::NodeId)\n\nCompute If-Then-Else: ITE(f, g, h) = (f ∧ g) ∨ (¬f ∧ h)\n\nThis is the fundamental BDD operation. All other operations can be expressed in terms of ITE:\n\nAND(f, g) = ITE(f, g, 0)\nOR(f, g) = ITE(f, 1, g)\nXOR(f, g) = ITE(f, ¬g, g)\nNOT(f) = ITE(f, 0, 1)\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantification","page":"API Reference","title":"Quantification","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.bdd_exists","page":"API Reference","title":"AlgebraicDecisionDiagrams.bdd_exists","text":"bdd_exists(mgr::DDManager, f::NodeId, vars::Vector{Int})\n\nExistential quantification: ∃vars. f = f[vars=0] ∨ f[vars=1]\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.bdd_forall","page":"API Reference","title":"AlgebraicDecisionDiagrams.bdd_forall","text":"bdd_forall(mgr::DDManager, f::NodeId, vars::Vector{Int})\n\nUniversal quantification: ∀vars. f = f[vars=0] ∧ f[vars=1]\n\n\n\n\n\n","category":"function"},{"location":"api/#Restriction","page":"API Reference","title":"Restriction","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.bdd_restrict","page":"API Reference","title":"AlgebraicDecisionDiagrams.bdd_restrict","text":"bdd_restrict(mgr::DDManager, f::NodeId, var::Int, value::Bool)\n\nRestrict a BDD by setting a variable to a constant value. This is also known as the cofactor operation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Algebraic-Decision-Diagrams-(ADDs)","page":"API Reference","title":"Algebraic Decision Diagrams (ADDs)","text":"","category":"section"},{"location":"api/#Variable-Creation-2","page":"API Reference","title":"Variable Creation","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.add_ith_var","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_ith_var","text":"add_ith_var(mgr::DDManager, i::Int)\n\nCreate an ADD for the i-th variable (0-1 valued).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.add_const","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_const","text":"add_const(mgr::DDManager, value::Float64)\n\nCreate an ADD representing a constant value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Arithmetic-Operations","page":"API Reference","title":"Arithmetic Operations","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.add_plus","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_plus","text":"add_plus(mgr::DDManager, f::NodeId, g::NodeId)\n\nAdd two ADDs (pointwise addition).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.add_minus","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_minus","text":"add_minus(mgr::DDManager, f::NodeId, g::NodeId)\n\nSubtract two ADDs (pointwise subtraction).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.add_times","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_times","text":"add_times(mgr::DDManager, f::NodeId, g::NodeId)\n\nMultiply two ADDs (pointwise multiplication).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.add_divide","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_divide","text":"add_divide(mgr::DDManager, f::NodeId, g::NodeId)\n\nDivide two ADDs (pointwise division).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.add_negate","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_negate","text":"add_negate(mgr::DDManager, f::NodeId)\n\nNegate an ADD (multiply by -1).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.add_scalar_multiply","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_scalar_multiply","text":"add_scalar_multiply(mgr::DDManager, f::NodeId, scalar::Float64)\n\nMultiply an ADD by a scalar constant.\n\n\n\n\n\n","category":"function"},{"location":"api/#Min/Max-Operations","page":"API Reference","title":"Min/Max Operations","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.add_min","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_min","text":"add_min(mgr::DDManager, f::NodeId, g::NodeId)\n\nCompute minimum of two ADDs (pointwise).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.add_max","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_max","text":"add_max(mgr::DDManager, f::NodeId, g::NodeId)\n\nCompute maximum of two ADDs (pointwise).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.add_threshold","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_threshold","text":"add_threshold(mgr::DDManager, f::NodeId, threshold::Float64)\n\nConvert ADD to BDD by thresholding: result is 1 where f >= threshold, 0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.add_find_min","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_find_min","text":"add_find_min(mgr::DDManager, f::NodeId)\n\nFind the minimum terminal value in an ADD.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.add_find_max","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_find_max","text":"add_find_max(mgr::DDManager, f::NodeId)\n\nFind the maximum terminal value in an ADD.\n\n\n\n\n\n","category":"function"},{"location":"api/#Restriction-2","page":"API Reference","title":"Restriction","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.add_restrict","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_restrict","text":"add_restrict(mgr::DDManager, f::NodeId, var::Int, value::Bool)\n\nRestrict an ADD by setting a variable to a constant value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Evaluation","page":"API Reference","title":"Evaluation","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.add_eval","page":"API Reference","title":"AlgebraicDecisionDiagrams.add_eval","text":"add_eval(mgr::DDManager, f::NodeId, assignment::Dict{Int,Bool})\n\nEvaluate an ADD given a complete variable assignment. Returns the terminal value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Zero-suppressed-Decision-Diagrams-(ZDDs)","page":"API Reference","title":"Zero-suppressed Decision Diagrams (ZDDs)","text":"","category":"section"},{"location":"api/#Set-Creation","page":"API Reference","title":"Set Creation","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_singleton","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_singleton","text":"zdd_singleton(mgr::DDManager, var::Int)\n\nCreate a ZDD representing the set containing only the singleton {var}.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_from_sets","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_from_sets","text":"zdd_from_sets(mgr::DDManager, sets::Vector{Vector{Int}})\n\nCreate a ZDD from a collection of sets. Each set is represented as a vector of variable indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_to_sets","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_to_sets","text":"zdd_to_sets(mgr::DDManager, f::NodeId)\n\nExtract all sets represented by a ZDD. Returns a vector of sets, where each set is a vector of variable indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_empty","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_empty","text":"zdd_empty(mgr::DDManager)\n\nReturn the empty set (ZDD zero terminal). In ZDDs, this represents the empty family of sets.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_base","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_base","text":"zdd_base(mgr::DDManager)\n\nReturn the base set (ZDD one terminal). In ZDDs, this represents the family containing only the empty set {∅}.\n\n\n\n\n\n","category":"function"},{"location":"api/#Set-Operations","page":"API Reference","title":"Set Operations","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_union","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_union","text":"zdd_union(mgr::DDManager, f::NodeId, g::NodeId)\n\nCompute the union of two ZDD sets: f ∪ g\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_intersection","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_intersection","text":"zdd_intersection(mgr::DDManager, f::NodeId, g::NodeId)\n\nCompute the intersection of two ZDD sets: f ∩ g\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_difference","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_difference","text":"zdd_difference(mgr::DDManager, f::NodeId, g::NodeId)\n\nCompute the set difference: f \\ g (elements in f but not in g)\n\n\n\n\n\n","category":"function"},{"location":"api/#ZDD-Specific-Operations","page":"API Reference","title":"ZDD-Specific Operations","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_subset0","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_subset0","text":"zdd_subset0(mgr::DDManager, f::NodeId, var::Int)\n\nReturn the subset of f where var is absent (negative cofactor).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_subset1","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_subset1","text":"zdd_subset1(mgr::DDManager, f::NodeId, var::Int)\n\nReturn the subset of f where var is present (positive cofactor).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_change","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_change","text":"zdd_change(mgr::DDManager, f::NodeId, var::Int)\n\nChange operation: add var to sets not containing it, remove from sets containing it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Counting","page":"API Reference","title":"Counting","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.zdd_count","page":"API Reference","title":"AlgebraicDecisionDiagrams.zdd_count","text":"zdd_count(mgr::DDManager, f::NodeId)\n\nCount the number of sets (combinations) represented by the ZDD.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api/#Counting-2","page":"API Reference","title":"Counting","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.count_nodes","page":"API Reference","title":"AlgebraicDecisionDiagrams.count_nodes","text":"count_nodes(mgr::DDManager, f::NodeId)\n\nCount the number of nodes in a BDD/ADD (excluding terminals).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.count_paths","page":"API Reference","title":"AlgebraicDecisionDiagrams.count_paths","text":"count_paths(mgr::DDManager, f::NodeId)\n\nCount the number of paths from root to 1-terminal (for BDDs).\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.count_minterms","page":"API Reference","title":"AlgebraicDecisionDiagrams.count_minterms","text":"count_minterms(mgr::DDManager, f::NodeId, nvars::Int)\n\nCount the number of satisfying assignments (minterms) for a BDD.\n\n\n\n\n\n","category":"function"},{"location":"api/#Visualization-and-Debugging","page":"API Reference","title":"Visualization and Debugging","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.print_dd","page":"API Reference","title":"AlgebraicDecisionDiagrams.print_dd","text":"print_dd(mgr::DDManager, f::NodeId; max_depth::Int=10)\n\nPrint a textual representation of a decision diagram.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.to_dot","page":"API Reference","title":"AlgebraicDecisionDiagrams.to_dot","text":"to_dot(mgr::DDManager, f::NodeId, filename::String)\n\nExport a decision diagram to DOT format for visualization with Graphviz.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memory-Management","page":"API Reference","title":"Memory Management","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.garbage_collect!","page":"API Reference","title":"AlgebraicDecisionDiagrams.garbage_collect!","text":"garbage_collect!(mgr::DDManager)\n\nPerform garbage collection to reclaim dead nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDecisionDiagrams.check_gc","page":"API Reference","title":"AlgebraicDecisionDiagrams.check_gc","text":"check_gc(mgr::DDManager)\n\nCheck if garbage collection should be triggered and run it if needed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#AlgebraicDecisionDiagrams.NodeId","page":"API Reference","title":"AlgebraicDecisionDiagrams.NodeId","text":"NodeId\n\nA node identifier that encodes both the node reference and complement bit. The LSB is used for complement edges (BDD only).\n\n\n\n\n\n","category":"type"},{"location":"api/#Performance-Notes","page":"API Reference","title":"Performance Notes","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"All operations use caching for O(1) repeated operations\nBDD NOT is O(1) using complement edges\nMost operations are zero-allocation for cached results\nVariable ordering significantly affects BDD size","category":"page"},{"location":"api/#See-Also","page":"API Reference","title":"See Also","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Getting Started: Basic usage examples\nBDD Guide: Binary Decision Diagrams\nADD Guide: Algebraic Decision Diagrams\nZDD Guide: Zero-suppressed Decision Diagrams\nPerformance: Performance characteristics","category":"page"},{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"This page provides detailed information about the performance characteristics of AlgebraicDecisionDiagrams.jl and how to optimize your code.","category":"page"},{"location":"performance/#Performance-Overview","page":"Performance","title":"Performance Overview","text":"","category":"section"},{"location":"performance/#Benchmark-Results","page":"Performance","title":"Benchmark Results","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"AlgebraicDecisionDiagrams.jl achieves excellent performance compared to CUDD:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Metric Julia CUDD Advantage\nBDD AND (warm) 5 ns 27 ns Julia 5.5x faster\nBDD OR (warm) 5 ns 26 ns Julia 5.2x faster\nBDD XOR (warm) 5 ns 15 ns Julia 3.0x faster\nBDD ITE (warm) 6 ns 16 ns Julia 2.7x faster\nMemory allocations 0 N/A Julia\nCold start ~900 μs ~900 μs Comparable","category":"page"},{"location":"performance/#Warm-vs-Cold-Performance","page":"Performance","title":"Warm vs Cold Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Warm Performance (cached operations):","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Measures steady-state performance after initialization\nRelevant for long-running applications, REPL usage, servers\nJulia: 3-1100x faster than CUDD","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Cold Performance (with initialization):","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Includes manager creation and setup overhead\nRelevant for short-lived scripts\nJulia and CUDD: Comparable (~1x)","category":"page"},{"location":"performance/#Zero-Allocations","page":"Performance","title":"Zero Allocations","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"All hot-path operations achieve zero allocations:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"using BenchmarkTools\n\nmgr = DDManager(10)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\n\n# Check allocations\n@benchmark bdd_and($mgr, $x1, $x2)\n# Memory estimate: 0 bytes\n# Allocs estimate: 0","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"This is achieved through:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Careful use of @inline directives\nStack-allocated temporaries\nEfficient caching strategies\nType-stable code","category":"page"},{"location":"performance/#Performance-Characteristics","page":"Performance","title":"Performance Characteristics","text":"","category":"section"},{"location":"performance/#Operation-Complexity","page":"Performance","title":"Operation Complexity","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Operation Time Complexity Space Complexity\nVariable creation O(1) O(1)\nNOT O(1) O(1)\nAND/OR/XOR O(|f| × |g|) worst case O(|f| × |g|) worst case\nITE O(|f| × |g| × |h|) worst case O(|f| × |g| × |h|) worst case\nExists/Forall O(|f|²) worst case O(|f|²) worst case\nRestrict O(|f|) O(|f|)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Note: With caching, repeated operations are O(1).","category":"page"},{"location":"performance/#Caching-Impact","page":"Performance","title":"Caching Impact","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Operations are automatically cached:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"mgr = DDManager(10)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\n\n# First call: computes and caches\n@time result1 = bdd_and(mgr, x1, x2)  # ~5 ns\n\n# Second call: cache hit\n@time result2 = bdd_and(mgr, x1, x2)  # ~5 ns (from cache)\n\n@assert result1 == result2","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Cache hit rate typically exceeds 90% for realistic workloads.","category":"page"},{"location":"performance/#Optimization-Techniques","page":"Performance","title":"Optimization Techniques","text":"","category":"section"},{"location":"performance/#1.-Variable-Ordering","page":"Performance","title":"1. Variable Ordering","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Variable ordering dramatically affects BDD size:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"mgr = DDManager(6)\n\n# Good ordering: related variables together\n# f = (x1 ∧ x2) ∨ (x3 ∧ x4) ∨ (x5 ∧ x6)\n# Order: x1, x2, x3, x4, x5, x6\nvars = [ith_var(mgr, i) for i in 1:6]\nf_good = bdd_or(mgr,\n    bdd_or(mgr,\n        bdd_and(mgr, vars[1], vars[2]),\n        bdd_and(mgr, vars[3], vars[4])),\n    bdd_and(mgr, vars[5], vars[6]))\n\nnodes_good = count_nodes(mgr, f_good)\nprintln(\"Good ordering: \", nodes_good, \" nodes\")\n\n# Bad ordering: interleaved variables\n# Order: x1, x3, x5, x2, x4, x6\n# Would result in larger BDD","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Tips:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Group related variables together\nPut frequently-used variables near the top\nConsider problem structure when assigning indices\nDynamic reordering not yet implemented","category":"page"},{"location":"performance/#2.-Reuse-Managers","page":"Performance","title":"2. Reuse Managers","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Manager creation has overhead (~900μs):","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"using BenchmarkTools\n\n# Good: Reuse manager\nmgr = DDManager(10)\n@benchmark begin\n    x = ith_var($mgr, 1)\n    y = ith_var($mgr, 2)\n    bdd_and($mgr, x, y)\nend\n# Fast: ~15 ns\n\n# Bad: Create manager each time\n@benchmark begin\n    mgr = DDManager(10)\n    x = ith_var(mgr, 1)\n    y = ith_var(mgr, 2)\n    bdd_and(mgr, x, y)\nend\n# Slow: ~900 μs","category":"page"},{"location":"performance/#3.-Build-Bottom-Up","page":"Performance","title":"3. Build Bottom-Up","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Build complex formulas incrementally:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"mgr = DDManager(10)\nvars = [ith_var(mgr, i) for i in 1:10]\n\n# Good: Incremental construction\nresult = vars[1]\nfor i in 2:10\n    result = bdd_and(mgr, result, vars[i])\nend\n\n# Also good: Use reduce\nresult = reduce((acc, v) -> bdd_and(mgr, acc, v), vars)\n\n# Bad: Deeply nested calls (harder to optimize)\nresult = bdd_and(mgr, vars[1],\n    bdd_and(mgr, vars[2],\n        bdd_and(mgr, vars[3],\n            # ... many levels deep\n        )))","category":"page"},{"location":"performance/#4.-Choose-Appropriate-DD-Type","page":"Performance","title":"4. Choose Appropriate DD Type","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Use the right tool for the job:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# BDDs: Boolean functions\nmgr = DDManager(10)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nf = bdd_and(mgr, x1, x2)  # Fast, compact\n\n# ADDs: Numeric functions\na1 = add_ith_var(mgr, 1)\na2 = add_ith_var(mgr, 2)\ng = add_plus(mgr, a1, a2)  # Appropriate for arithmetic\n\n# ZDDs: Sparse sets\ns1 = zdd_singleton(mgr, 1)\ns2 = zdd_singleton(mgr, 2)\nh = zdd_union(mgr, s1, s2)  # Efficient for set operations","category":"page"},{"location":"performance/#5.-Avoid-Unnecessary-Conversions","page":"Performance","title":"5. Avoid Unnecessary Conversions","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Conversions have overhead:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"mgr = DDManager(3)\n\n# Good: Work in one domain\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nresult = bdd_and(mgr, x1, x2)\n\n# Bad: Unnecessary conversions\nx1_bdd = ith_var(mgr, 1)\nx1_add = bdd_to_add(mgr, x1_bdd)  # Conversion overhead\nx1_back = add_to_bdd(mgr, x1_add)  # More overhead","category":"page"},{"location":"performance/#Profiling","page":"Performance","title":"Profiling","text":"","category":"section"},{"location":"performance/#Using-BenchmarkTools","page":"Performance","title":"Using BenchmarkTools","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"using BenchmarkTools\nusing AlgebraicDecisionDiagrams\n\nmgr = DDManager(10)\nvars = [ith_var(mgr, i) for i in 1:10]\n\n# Benchmark a complex operation\n@benchmark begin\n    result = $vars[1]\n    for i in 2:10\n        result = bdd_and($mgr, result, $vars[i])\n    end\nend","category":"page"},{"location":"performance/#Using-Profile","page":"Performance","title":"Using Profile","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"using Profile\nusing AlgebraicDecisionDiagrams\n\nmgr = DDManager(100)\n\n# Profile a workload\n@profile begin\n    for i in 1:1000\n        x = ith_var(mgr, i % 100 + 1)\n        y = ith_var(mgr, (i+1) % 100 + 1)\n        result = bdd_and(mgr, x, y)\n    end\nend\n\n# View results\nProfile.print()","category":"page"},{"location":"performance/#Memory-Usage","page":"Performance","title":"Memory Usage","text":"","category":"section"},{"location":"performance/#Node-Memory","page":"Performance","title":"Node Memory","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Each node uses minimal memory:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"mgr = DDManager(10)\n\n# Create nodes\nfor i in 1:10\n    x = ith_var(mgr, i)\nend\n\n# Check memory\nnode_size = sizeof(mgr.nodes[1])\ntotal_nodes = length(mgr.nodes)\nnode_memory = node_size * total_nodes\n\nprintln(\"Node size: \", node_size, \" bytes\")\nprintln(\"Total nodes: \", total_nodes)\nprintln(\"Node memory: \", node_memory, \" bytes\")","category":"page"},{"location":"performance/#Cache-Memory","page":"Performance","title":"Cache Memory","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"The computed table uses direct-mapped caching:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"mgr = DDManager(10)\n\ncache_size = length(mgr.cache.entries)\nentry_size = sizeof(mgr.cache.entries[1])\ncache_memory = cache_size * entry_size\n\nprintln(\"Cache size: \", cache_size, \" entries\")\nprintln(\"Cache memory: \", cache_memory, \" bytes\")","category":"page"},{"location":"performance/#Scalability","page":"Performance","title":"Scalability","text":"","category":"section"},{"location":"performance/#Problem-Size","page":"Performance","title":"Problem Size","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Performance scales well with problem size:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"using BenchmarkTools\n\nfor n in [10, 20, 50, 100]\n    mgr = DDManager(n)\n    vars = [ith_var(mgr, i) for i in 1:n]\n\n    b = @benchmark begin\n        result = $vars[1]\n        for i in 2:$n\n            result = bdd_and($mgr, result, $vars[i])\n        end\n    end\n\n    println(\"n=$n: \", median(b.times) / 1000, \" μs\")\nend","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Expected output:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"n=10: 0.05 μs\nn=20: 0.14 μs\nn=50: 0.40 μs\nn=100: 0.90 μs","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Linear scaling for chain operations.","category":"page"},{"location":"performance/#Node-Count-Growth","page":"Performance","title":"Node Count Growth","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"BDD size depends on function complexity and variable ordering:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"mgr = DDManager(10)\nvars = [ith_var(mgr, i) for i in 1:10]\n\n# Linear growth: AND chain\nresult = vars[1]\nfor i in 2:10\n    result = bdd_and(mgr, result, vars[i])\nend\nprintln(\"AND chain nodes: \", count_nodes(mgr, result))  # 10\n\n# Exponential growth: bad ordering\n# (Some functions can have exponential blowup)","category":"page"},{"location":"performance/#Comparison-with-CUDD","page":"Performance","title":"Comparison with CUDD","text":"","category":"section"},{"location":"performance/#Detailed-Benchmarks","page":"Performance","title":"Detailed Benchmarks","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"See benchmark/cudd_comparison/RESULTS.md for comprehensive benchmarks.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Key findings:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Warm operations: Julia 3-1100x faster\nCold operations: Comparable\nZero allocations: Julia advantage\nVariable reordering: CUDD advantage (not yet in Julia)\nMulti-threading: CUDD advantage (not yet in Julia)","category":"page"},{"location":"performance/#When-to-Use-Each","page":"Performance","title":"When to Use Each","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Use Julia when:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Interactive development (REPL, notebooks)\nLong-running applications\nPerformance is critical\nType safety matters\nIntegration with Julia ecosystem","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Use CUDD when:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Variable reordering is essential\nMulti-threading required\nVery large problems (>10M nodes) with reordering\nIntegration with C/C++ code","category":"page"},{"location":"performance/#Future-Optimizations","page":"Performance","title":"Future Optimizations","text":"","category":"section"},{"location":"performance/#Planned-Improvements","page":"Performance","title":"Planned Improvements","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Variable Reordering (High Priority)\nSIFT algorithm\nDynamic reordering\nExpected: 10-100x improvement for large problems\nMulti-threading (Medium Priority)\nParallel operations\nThread-safe caching\nExpected: 2-8x improvement on multi-core\nSIMD Operations (Low Priority)\nVectorized operations where applicable\nExpected: 1.5-2x improvement for specific operations","category":"page"},{"location":"performance/#Best-Practices-Summary","page":"Performance","title":"Best Practices Summary","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"✅ Reuse managers across operations\n✅ Choose good variable ordering\n✅ Build formulas bottom-up\n✅ Use appropriate DD type (BDD/ADD/ZDD)\n✅ Avoid unnecessary conversions\n✅ Profile before optimizing\n✅ Leverage caching (automatic)\n✅ Monitor memory usage for large problems","category":"page"},{"location":"performance/#See-Also","page":"Performance","title":"See Also","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Comparison with CUDD: Detailed benchmark comparison\nAPI Reference: Complete API documentation\nInternals: Implementation details","category":"page"},{"location":"guide/bdds/#Binary-Decision-Diagrams-(BDDs)","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Binary Decision Diagrams (BDDs) are canonical representations of Boolean functions. They are widely used in formal verification, logic synthesis, and combinatorial optimization.","category":"page"},{"location":"guide/bdds/#What-are-BDDs?","page":"Binary Decision Diagrams (BDDs)","title":"What are BDDs?","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"A BDD is a directed acyclic graph (DAG) where:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Each non-terminal node represents a Boolean variable\nEach node has two children: then (high) and else (low)\nTerminal nodes represent Boolean values (true/false)\nThe graph is reduced and ordered for canonical representation","category":"page"},{"location":"guide/bdds/#Creating-BDDs","page":"Binary Decision Diagrams (BDDs)","title":"Creating BDDs","text":"","category":"section"},{"location":"guide/bdds/#Variables","page":"Binary Decision Diagrams (BDDs)","title":"Variables","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Create Boolean variables using ith_var:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"using AlgebraicDecisionDiagrams\n\nmgr = DDManager(5)\n\n# Create variables x1, x2, x3, x4, x5\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nx3 = ith_var(mgr, 3)\nx4 = ith_var(mgr, 4)\nx5 = ith_var(mgr, 5)","category":"page"},{"location":"guide/bdds/#Constants","page":"Binary Decision Diagrams (BDDs)","title":"Constants","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Access Boolean constants directly from the manager:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"true_node = mgr.one   # Constant true\nfalse_node = mgr.zero # Constant false","category":"page"},{"location":"guide/bdds/#Boolean-Operations","page":"Binary Decision Diagrams (BDDs)","title":"Boolean Operations","text":"","category":"section"},{"location":"guide/bdds/#Basic-Operations","page":"Binary Decision Diagrams (BDDs)","title":"Basic Operations","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nx3 = ith_var(mgr, 3)\n\n# AND: x1 ∧ x2\nf_and = bdd_and(mgr, x1, x2)\n\n# OR: x1 ∨ x2\nf_or = bdd_or(mgr, x1, x2)\n\n# XOR: x1 ⊕ x2\nf_xor = bdd_xor(mgr, x1, x2)\n\n# NOT: ¬x1\nf_not = bdd_not(mgr, x1)\n\n# NAND: ¬(x1 ∧ x2)\nf_nand = bdd_not(mgr, bdd_and(mgr, x1, x2))\n\n# NOR: ¬(x1 ∨ x2)\nf_nor = bdd_not(mgr, bdd_or(mgr, x1, x2))\n\n# XNOR: ¬(x1 ⊕ x2) (equivalence)\nf_xnor = bdd_not(mgr, bdd_xor(mgr, x1, x2))\n\n# IMPLIES: x1 → x2 = ¬x1 ∨ x2\nf_implies = bdd_or(mgr, bdd_not(mgr, x1), x2)","category":"page"},{"location":"guide/bdds/#If-Then-Else-(ITE)","page":"Binary Decision Diagrams (BDDs)","title":"If-Then-Else (ITE)","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"The ITE operation is fundamental: ITE(f, g, h) = (f ∧ g) ∨ (¬f ∧ h)","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nx3 = ith_var(mgr, 3)\n\n# If x1 then x2 else x3\nresult = bdd_ite(mgr, x1, x2, x3)\n\n# Equivalent to: (x1 ∧ x2) ∨ (¬x1 ∧ x3)\nequivalent = bdd_or(mgr,\n    bdd_and(mgr, x1, x2),\n    bdd_and(mgr, bdd_not(mgr, x1), x3))\n\n# They are the same\n@assert result == equivalent","category":"page"},{"location":"guide/bdds/#Complex-Formulas","page":"Binary Decision Diagrams (BDDs)","title":"Complex Formulas","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Build complex Boolean formulas by composing operations:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(4)\nx1, x2, x3, x4 = [ith_var(mgr, i) for i in 1:4]\n\n# Majority function: at least 2 of 3 variables are true\n# maj(x1, x2, x3) = (x1 ∧ x2) ∨ (x1 ∧ x3) ∨ (x2 ∧ x3)\nmajority = bdd_or(mgr,\n    bdd_or(mgr,\n        bdd_and(mgr, x1, x2),\n        bdd_and(mgr, x1, x3)),\n    bdd_and(mgr, x2, x3))\n\n# Full adder carry: c_out = (a ∧ b) ∨ (a ∧ c_in) ∨ (b ∧ c_in)\ncarry = bdd_or(mgr,\n    bdd_or(mgr,\n        bdd_and(mgr, x1, x2),\n        bdd_and(mgr, x1, x3)),\n    bdd_and(mgr, x2, x3))\n\n# Full adder sum: s = a ⊕ b ⊕ c_in\nsum = bdd_xor(mgr, bdd_xor(mgr, x1, x2), x3)\n\n# Parity: odd number of true variables\nparity = bdd_xor(mgr, bdd_xor(mgr, bdd_xor(mgr, x1, x2), x3), x4)","category":"page"},{"location":"guide/bdds/#Quantification","page":"Binary Decision Diagrams (BDDs)","title":"Quantification","text":"","category":"section"},{"location":"guide/bdds/#Existential-Quantification","page":"Binary Decision Diagrams (BDDs)","title":"Existential Quantification","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"∃x. f(x, y) returns true if f is true for at least one value of x:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nx3 = ith_var(mgr, 3)\n\n# f = x1 ∧ x2 ∧ x3\nf = bdd_and(mgr, bdd_and(mgr, x1, x2), x3)\n\n# ∃x2. f = x1 ∧ x3 (true if x1 and x3 are true, regardless of x2)\nexists_x2 = bdd_exists(mgr, f, 2)\n\n# Verify: should be equivalent to x1 ∧ x3\nexpected = bdd_and(mgr, x1, x3)\n@assert exists_x2 == expected","category":"page"},{"location":"guide/bdds/#Universal-Quantification","page":"Binary Decision Diagrams (BDDs)","title":"Universal Quantification","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"∀x. f(x, y) returns true if f is true for all values of x:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nx3 = ith_var(mgr, 3)\n\n# f = x1 ∨ x2\nf = bdd_or(mgr, x1, x2)\n\n# ∀x2. f = x1 (true only if x1 is true, since x2 could be false)\nforall_x2 = bdd_forall(mgr, f, 2)\n\n# Verify: should be equivalent to x1\n@assert forall_x2 == x1","category":"page"},{"location":"guide/bdds/#Multiple-Variables","page":"Binary Decision Diagrams (BDDs)","title":"Multiple Variables","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Quantify over multiple variables:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(4)\nx1, x2, x3, x4 = [ith_var(mgr, i) for i in 1:4]\n\n# f = (x1 ∧ x2) ∨ (x3 ∧ x4)\nf = bdd_or(mgr,\n    bdd_and(mgr, x1, x2),\n    bdd_and(mgr, x3, x4))\n\n# ∃x2, x4. f = x1 ∨ x3\nresult = bdd_exists(mgr, bdd_exists(mgr, f, 2), 4)","category":"page"},{"location":"guide/bdds/#Restriction-(Cofactoring)","page":"Binary Decision Diagrams (BDDs)","title":"Restriction (Cofactoring)","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Restriction fixes a variable to a specific value:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nx3 = ith_var(mgr, 3)\n\n# f = (x1 ∧ x2) ∨ x3\nf = bdd_or(mgr, bdd_and(mgr, x1, x2), x3)\n\n# Restrict x2 = true: f|x2=1 = x1 ∨ x3\nf_x2_true = bdd_restrict(mgr, f, 2, true)\n\n# Restrict x2 = false: f|x2=0 = x3\nf_x2_false = bdd_restrict(mgr, f, 2, false)\n\n# Verify Shannon expansion: f = (x2 ∧ f|x2=1) ∨ (¬x2 ∧ f|x2=0)\nshannon = bdd_or(mgr,\n    bdd_and(mgr, x2, f_x2_true),\n    bdd_and(mgr, bdd_not(mgr, x2), f_x2_false))\n@assert shannon == f","category":"page"},{"location":"guide/bdds/#Evaluation","page":"Binary Decision Diagrams (BDDs)","title":"Evaluation","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Evaluate a BDD with a specific variable assignment:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nx3 = ith_var(mgr, 3)\n\n# f = (x1 ∧ x2) ∨ x3\nf = bdd_or(mgr, bdd_and(mgr, x1, x2), x3)\n\n# Evaluate with x1=true, x2=true, x3=false\nassignment = Dict(1 => true, 2 => true, 3 => false)\nresult = bdd_eval(mgr, f, assignment)  # true\n\n# Evaluate with x1=true, x2=false, x3=false\nassignment = Dict(1 => true, 2 => false, 3 => false)\nresult = bdd_eval(mgr, f, assignment)  # false\n\n# Evaluate with x1=false, x2=false, x3=true\nassignment = Dict(1 => false, 2 => false, 3 => true)\nresult = bdd_eval(mgr, f, assignment)  # true","category":"page"},{"location":"guide/bdds/#Counting-and-Analysis","page":"Binary Decision Diagrams (BDDs)","title":"Counting and Analysis","text":"","category":"section"},{"location":"guide/bdds/#Count-Nodes","page":"Binary Decision Diagrams (BDDs)","title":"Count Nodes","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Count the number of nodes in the BDD:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\n\n# Simple AND: 2 nodes (x1 and x2)\nf = bdd_and(mgr, x1, x2)\nprintln(\"Nodes: \", count_nodes(mgr, f))  # 2","category":"page"},{"location":"guide/bdds/#Count-Paths","page":"Binary Decision Diagrams (BDDs)","title":"Count Paths","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Count the number of paths from root to true terminal:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\n\n# x1 ∧ x2: one path (both true)\nf = bdd_and(mgr, x1, x2)\nprintln(\"Paths: \", count_paths(mgr, f))  # 1\n\n# x1 ∨ x2: three paths (x1 true, x2 true, or both)\ng = bdd_or(mgr, x1, x2)\nprintln(\"Paths: \", count_paths(mgr, g))  # 3","category":"page"},{"location":"guide/bdds/#Count-Minterms","page":"Binary Decision Diagrams (BDDs)","title":"Count Minterms","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Count the number of satisfying assignments:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nx3 = ith_var(mgr, 3)\n\n# x1 ∧ x2: 2 minterms out of 8 (x3 can be 0 or 1)\nf = bdd_and(mgr, x1, x2)\nprintln(\"Minterms: \", count_minterms(mgr, f, 3))  # 2.0\n\n# x1 ∨ x2: 6 minterms out of 8\ng = bdd_or(mgr, x1, x2)\nprintln(\"Minterms: \", count_minterms(mgr, g, 3))  # 6.0\n\n# Probability (assuming uniform distribution)\nprob = count_minterms(mgr, g, 3) / 2^3  # 0.75","category":"page"},{"location":"guide/bdds/#Complement-Edges","page":"Binary Decision Diagrams (BDDs)","title":"Complement Edges","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"BDDs in this implementation use complement edges for efficiency:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"The least significant bit (LSB) of a node pointer indicates negation\nNOT operation is O(1) - just flip the LSB\nReduces node count by approximately 2x","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(2)\nx1 = ith_var(mgr, 1)\n\n# NOT is extremely fast (just bit flip)\nnot_x1 = bdd_not(mgr, x1)\n\n# Double negation returns original\n@assert bdd_not(mgr, not_x1) == x1\n\n# Complement edges are transparent to users\n# All operations handle them automatically","category":"page"},{"location":"guide/bdds/#Performance-Tips","page":"Binary Decision Diagrams (BDDs)","title":"Performance Tips","text":"","category":"section"},{"location":"guide/bdds/#1.-Variable-Ordering","page":"Binary Decision Diagrams (BDDs)","title":"1. Variable Ordering","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Variable ordering significantly affects BDD size:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"# Good: Related variables close together\n# f = (x1 ∧ x2) ∨ (x3 ∧ x4)\n# Order: x1, x2, x3, x4 → small BDD\n\n# Bad: Interleaved variables\n# Order: x1, x3, x2, x4 → larger BDD\n\n# Note: Dynamic reordering not yet implemented","category":"page"},{"location":"guide/bdds/#2.-Operation-Caching","page":"Binary Decision Diagrams (BDDs)","title":"2. Operation Caching","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Operations are automatically cached:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(10)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\n\n# First call: computes and caches\nresult1 = bdd_and(mgr, x1, x2)  # ~5 ns\n\n# Second call: cache hit\nresult2 = bdd_and(mgr, x1, x2)  # ~5 ns (from cache)\n\n@assert result1 == result2","category":"page"},{"location":"guide/bdds/#3.-Build-Bottom-Up","page":"Binary Decision Diagrams (BDDs)","title":"3. Build Bottom-Up","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Build BDDs bottom-up for better performance:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(4)\nvars = [ith_var(mgr, i) for i in 1:4]\n\n# Good: Build incrementally\nresult = vars[1]\nfor i in 2:4\n    result = bdd_and(mgr, result, vars[i])\nend\n\n# Also good: Use reduce\nresult = reduce((acc, v) -> bdd_and(mgr, acc, v), vars)","category":"page"},{"location":"guide/bdds/#Common-Patterns","page":"Binary Decision Diagrams (BDDs)","title":"Common Patterns","text":"","category":"section"},{"location":"guide/bdds/#Encoding-Constraints","page":"Binary Decision Diagrams (BDDs)","title":"Encoding Constraints","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(4)\nx1, x2, x3, x4 = [ith_var(mgr, i) for i in 1:4]\n\n# At least one variable is true\nat_least_one = bdd_or(mgr, bdd_or(mgr, bdd_or(mgr, x1, x2), x3), x4)\n\n# Exactly one variable is true\nexactly_one = bdd_and(mgr,\n    at_least_one,\n    bdd_and(mgr,\n        bdd_not(mgr, bdd_and(mgr, x1, x2)),\n        bdd_and(mgr,\n            bdd_not(mgr, bdd_and(mgr, x1, x3)),\n            bdd_and(mgr,\n                bdd_not(mgr, bdd_and(mgr, x1, x4)),\n                bdd_and(mgr,\n                    bdd_not(mgr, bdd_and(mgr, x2, x3)),\n                    bdd_and(mgr,\n                        bdd_not(mgr, bdd_and(mgr, x2, x4)),\n                        bdd_not(mgr, bdd_and(mgr, x3, x4))))))))\n\n# At most two variables are true\nat_most_two = bdd_not(mgr,\n    bdd_or(mgr,\n        bdd_and(mgr, bdd_and(mgr, x1, x2), x3),\n        bdd_or(mgr,\n            bdd_and(mgr, bdd_and(mgr, x1, x2), x4),\n            bdd_or(mgr,\n                bdd_and(mgr, bdd_and(mgr, x1, x3), x4),\n                bdd_and(mgr, bdd_and(mgr, x2, x3), x4)))))","category":"page"},{"location":"guide/bdds/#SAT-Solving","page":"Binary Decision Diagrams (BDDs)","title":"SAT Solving","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"Check if a formula is satisfiable:","category":"page"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nx3 = ith_var(mgr, 3)\n\n# Formula: (x1 ∨ x2) ∧ (¬x1 ∨ x3) ∧ (¬x2 ∨ ¬x3)\nclause1 = bdd_or(mgr, x1, x2)\nclause2 = bdd_or(mgr, bdd_not(mgr, x1), x3)\nclause3 = bdd_or(mgr, bdd_not(mgr, x2), bdd_not(mgr, x3))\n\nformula = bdd_and(mgr, bdd_and(mgr, clause1, clause2), clause3)\n\n# Check satisfiability\nis_sat = formula != mgr.zero\nprintln(\"Satisfiable: \", is_sat)\n\n# Count solutions\nnum_solutions = count_minterms(mgr, formula, 3)\nprintln(\"Number of solutions: \", num_solutions)","category":"page"},{"location":"guide/bdds/#See-Also","page":"Binary Decision Diagrams (BDDs)","title":"See Also","text":"","category":"section"},{"location":"guide/bdds/","page":"Binary Decision Diagrams (BDDs)","title":"Binary Decision Diagrams (BDDs)","text":"ADD Guide: Algebraic Decision Diagrams\nZDD Guide: Zero-suppressed Decision Diagrams\nAPI Reference: Complete API documentation","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide will help you get started with AlgebraicDecisionDiagrams.jl.","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Install the package using Julia's package manager:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"AlgebraicDecisionDiagrams\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For development:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Pkg.develop(url=\"https://github.com/yourusername/AlgebraicDecisionDiagrams.jl\")","category":"page"},{"location":"getting_started/#Basic-Concepts","page":"Getting Started","title":"Basic Concepts","text":"","category":"section"},{"location":"getting_started/#Decision-Diagrams","page":"Getting Started","title":"Decision Diagrams","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Decision diagrams are directed acyclic graphs (DAGs) used to represent functions over discrete variables. They provide:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Canonical representation: Unique representation for each function\nEfficient operations: Boolean/arithmetic operations in polynomial time\nCompact storage: Often exponentially smaller than truth tables","category":"page"},{"location":"getting_started/#Manager","page":"Getting Started","title":"Manager","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"All operations require a DDManager that manages the unique table and operation cache:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using AlgebraicDecisionDiagrams\n\n# Create a manager for up to 10 variables\nmgr = DDManager(10)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The manager maintains:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Unique table for canonical node representation\nComputed table for operation memoization\nReference counting for memory management","category":"page"},{"location":"getting_started/#Your-First-BDD","page":"Getting Started","title":"Your First BDD","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's create a simple Boolean function: f(x₁, x₂) = x₁ ∧ x₂","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using AlgebraicDecisionDiagrams\n\n# Create manager\nmgr = DDManager(2)\n\n# Create variables\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\n\n# Create function: x1 AND x2\nf = bdd_and(mgr, x1, x2)\n\n# Count nodes\nprintln(\"Nodes: \", count_nodes(mgr, f))  # 2\n\n# Count satisfying assignments\nprintln(\"Minterms: \", count_minterms(mgr, f, 2))  # 1.0 (only 11 satisfies)\n\n# Evaluate\nassignment = Dict(1 => true, 2 => true)\nprintln(\"f(1,1) = \", bdd_eval(mgr, f, assignment))  # true\n\nassignment = Dict(1 => true, 2 => false)\nprintln(\"f(1,0) = \", bdd_eval(mgr, f, assignment))  # false","category":"page"},{"location":"getting_started/#Your-First-ADD","page":"Getting Started","title":"Your First ADD","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ADDs extend BDDs to real-valued functions:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using AlgebraicDecisionDiagrams\n\nmgr = DDManager(2)\n\n# Create ADD variables (0-1 functions)\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\n\n# Create constants\nc1 = add_const(mgr, 5.0)\nc2 = add_const(mgr, 3.0)\n\n# Arithmetic: f = 5*x1 + 3*x2\nf = add_plus(mgr,\n    add_times(mgr, c1, x1),\n    add_times(mgr, c2, x2))\n\n# Evaluate\nassignment = Dict(1 => 1.0, 2 => 1.0)\nprintln(\"f(1,1) = \", add_eval(mgr, f, assignment))  # 8.0\n\nassignment = Dict(1 => 1.0, 2 => 0.0)\nprintln(\"f(1,0) = \", add_eval(mgr, f, assignment))  # 5.0","category":"page"},{"location":"getting_started/#Your-First-ZDD","page":"Getting Started","title":"Your First ZDD","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ZDDs are optimized for representing sparse sets:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using AlgebraicDecisionDiagrams\n\nmgr = DDManager(4)\n\n# Create sets\nsets = [\n    [1, 2],    # {1, 2}\n    [2, 3],    # {2, 3}\n    [1, 3],    # {1, 3}\n    [4]        # {4}\n]\n\n# Create ZDD representing this family of sets\nfamily = zdd_from_sets(mgr, sets)\n\n# Count sets in family\nprintln(\"Number of sets: \", zdd_count(mgr, family))  # 4\n\n# Convert back to sets\nrecovered = zdd_to_sets(mgr, family)\nprintln(\"Sets: \", recovered)\n\n# Set operations\ns1 = zdd_singleton(mgr, 1)  # {1}\ns2 = zdd_singleton(mgr, 2)  # {2}\n\n# Union: {{1}, {2}}\nunion = zdd_union(mgr, s1, s2)\n\n# Product: {{1,2}}\nproduct = zdd_product(mgr, s1, s2)","category":"page"},{"location":"getting_started/#Common-Patterns","page":"Getting Started","title":"Common Patterns","text":"","category":"section"},{"location":"getting_started/#Building-Complex-Formulas","page":"Getting Started","title":"Building Complex Formulas","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mgr = DDManager(4)\nx1, x2, x3, x4 = [ith_var(mgr, i) for i in 1:4]\n\n# (x1 ∧ x2) ∨ (x3 ∧ x4)\nf = bdd_or(mgr,\n    bdd_and(mgr, x1, x2),\n    bdd_and(mgr, x3, x4))\n\n# ¬(x1 ⊕ x2)  (XNOR)\ng = bdd_not(mgr, bdd_xor(mgr, x1, x2))","category":"page"},{"location":"getting_started/#Quantification","page":"Getting Started","title":"Quantification","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mgr = DDManager(3)\nx1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\n\n# f = x1 ∧ x2 ∧ x3\nf = bdd_and(mgr, bdd_and(mgr, x1, x2), x3)\n\n# ∃x2. f = x1 ∧ x3\nexists_x2 = bdd_exists(mgr, f, 2)\n\n# ∀x2. f = false (not true for all x2)\nforall_x2 = bdd_forall(mgr, f, 2)","category":"page"},{"location":"getting_started/#Restriction","page":"Getting Started","title":"Restriction","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mgr = DDManager(3)\nx1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\n\n# f = x1 ∧ x2 ∧ x3\nf = bdd_and(mgr, bdd_and(mgr, x1, x2), x3)\n\n# Restrict x2 = true: f|x2=1 = x1 ∧ x3\nrestricted = bdd_restrict(mgr, f, 2, true)","category":"page"},{"location":"getting_started/#Performance-Tips","page":"Getting Started","title":"Performance Tips","text":"","category":"section"},{"location":"getting_started/#1.-Reuse-Managers","page":"Getting Started","title":"1. Reuse Managers","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Creating a manager has overhead (~900μs). Reuse managers when possible:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Good: One manager for all operations\nmgr = DDManager(10)\nfor i in 1:1000\n    x = ith_var(mgr, i % 10 + 1)\n    # ... operations ...\nend\n\n# Bad: Creating manager in loop\nfor i in 1:1000\n    mgr = DDManager(10)  # Expensive!\n    x = ith_var(mgr, 1)\nend","category":"page"},{"location":"getting_started/#2.-Variable-Ordering-Matters","page":"Getting Started","title":"2. Variable Ordering Matters","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Variable ordering significantly affects BDD size:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mgr = DDManager(4)\n\n# Good ordering for (x1 ∧ x2) ∨ (x3 ∧ x4)\nx1, x2, x3, x4 = [ith_var(mgr, i) for i in 1:4]\nf = bdd_or(mgr, bdd_and(mgr, x1, x2), bdd_and(mgr, x3, x4))\nprintln(\"Nodes: \", count_nodes(mgr, f))  # Small\n\n# Bad ordering can lead to exponential blowup\n# (Variable reordering not yet implemented)","category":"page"},{"location":"getting_started/#3.-Use-Appropriate-DD-Type","page":"Getting Started","title":"3. Use Appropriate DD Type","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"BDDs: Boolean functions, logic circuits\nADDs: Functions with numeric values, probabilities\nZDDs: Sparse sets, combinatorial problems","category":"page"},{"location":"getting_started/#4.-Monitor-Memory-Usage","page":"Getting Started","title":"4. Monitor Memory Usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mgr = DDManager(10)\n\n# ... many operations ...\n\n# Check statistics\nprintln(\"Total nodes: \", length(mgr.nodes))\nprintln(\"Cache size: \", length(mgr.cache.entries))\n\n# Garbage collection (if needed)\n# gc_collect(mgr)  # Not yet implemented","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"BDD Guide: Detailed guide to Binary Decision Diagrams\nADD Guide: Detailed guide to Algebraic Decision Diagrams\nZDD Guide: Detailed guide to Zero-suppressed Decision Diagrams\nPerformance: Performance optimization and benchmarking\nAPI Reference: Complete API documentation","category":"page"},{"location":"comparison/#Comparison-with-CUDD","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"This page provides a detailed comparison between AlgebraicDecisionDiagrams.jl and CUDD (Colorado University Decision Diagram library).","category":"page"},{"location":"comparison/#Overview","page":"Comparison with CUDD","title":"Overview","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"CUDD is the industry-standard C implementation of decision diagrams, developed at the University of Colorado Boulder. AlgebraicDecisionDiagrams.jl is a Julia implementation inspired by CUDD's architecture.","category":"page"},{"location":"comparison/#Architecture-Comparison","page":"Comparison with CUDD","title":"Architecture Comparison","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Both implementations share the same core architecture:","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Component CUDD (C) AlgebraicDecisionDiagrams.jl (Julia)\nUnique Table Hash table per variable level ✅ Same approach\nComputed Table Direct-mapped cache ✅ Same approach\nComplement Edges LSB of pointer for BDDs ✅ Same approach\nNode Structure 24-32 bytes ✅ Similar (with Julia overhead)\nReference Counting Manual ref/deref ✅ Implemented\nGarbage Collection Mark-and-sweep ✅ Implemented","category":"page"},{"location":"comparison/#Performance-Comparison","page":"Comparison with CUDD","title":"Performance Comparison","text":"","category":"section"},{"location":"comparison/#Warm-Performance-(Cached-Operations)","page":"Comparison with CUDD","title":"Warm Performance (Cached Operations)","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Measures steady-state performance with pre-initialized manager:","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Operation Julia (ns) CUDD (ns) Ratio Winner\nBDD AND 5 27.42 0.18x 🏆 Julia 5.5x faster\nBDD OR 5 25.91 0.19x 🏆 Julia 5.2x faster\nBDD XOR 5 14.90 0.34x 🏆 Julia 3.0x faster\nBDD NOT 2 0.10 20x ⚠️ CUDD 20x faster\nBDD ITE 6 16.00 0.38x 🏆 Julia 2.7x faster","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Note: CUDD's NOT is extremely fast (pointer bit flip). Julia's NOT also uses complement edges but has slightly more overhead.","category":"page"},{"location":"comparison/#Chain-Operations-(Warm)","page":"Comparison with CUDD","title":"Chain Operations (Warm)","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Problem Size Julia (μs) CUDD (μs) Ratio Winner\nn=5 0.02 12.80 0.0016x 🏆 Julia 640x faster\nn=10 0.05 51.20 0.0010x 🏆 Julia 1024x faster\nn=20 0.14 153.86 0.0009x 🏆 Julia 1099x faster\nn=50 0.40 429.06 0.0009x 🏆 Julia 1073x faster","category":"page"},{"location":"comparison/#Cold-Performance-(With-Initialization)","page":"Comparison with CUDD","title":"Cold Performance (With Initialization)","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Problem Size Julia (μs) CUDD (μs) Ratio Winner\nn=5 915.21 1111.81 0.82x 🏆 Julia 1.2x faster\nn=10 892.54 729.09 1.22x 🏆 CUDD 1.2x faster\nn=20 911.62 822.02 1.11x 🏆 Julia 1.1x faster\nn=50 961.96 791.04 1.22x 🏆 CUDD 1.2x faster","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Analysis: Cold performance is comparable, with initialization overhead dominating.","category":"page"},{"location":"comparison/#Feature-Comparison","page":"Comparison with CUDD","title":"Feature Comparison","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Feature CUDD Julia Implementation\nBDDs ✅ Full support ✅ Full support\nADDs ✅ Full support ✅ Full support\nZDDs ✅ Full support ✅ Full support\nVariable Reordering ✅ Multiple algorithms ⚠️ Not yet (future work)\nDynamic Reordering ✅ Automatic ⚠️ Not yet (future work)\nComplement Edges ✅ BDDs only ✅ BDDs only\nMulti-threading ✅ Supported ⚠️ Not yet (future work)\nType Safety ❌ None ✅ Full Julia type system\nMemory Safety ❌ Manual ✅ Automatic\nZero Allocations N/A ✅ All hot paths","category":"page"},{"location":"comparison/#Why-is-Julia-Faster-for-Warm-Operations?","page":"Comparison with CUDD","title":"Why is Julia Faster for Warm Operations?","text":"","category":"section"},{"location":"comparison/#1.-JIT-Compilation-Advantages","page":"Comparison with CUDD","title":"1. JIT Compilation Advantages","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Julia's LLVM-based JIT compiler generates highly optimized machine code:","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Aggressive inlining of hot paths\nType specialization eliminates dynamic dispatch\nModern LLVM optimizations (version 15+)\nARM64-specific optimizations on Apple Silicon","category":"page"},{"location":"comparison/#2.-Cache-Efficiency","page":"Comparison with CUDD","title":"2. Cache Efficiency","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Better cache locality in Julia's implementation\nSmaller memory footprint for operations\nMore efficient data structure layout","category":"page"},{"location":"comparison/#3.-Zero-Allocations","page":"Comparison with CUDD","title":"3. Zero Allocations","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"All cached operations have zero allocations\nNo GC pressure during hot loops\nStack-allocated temporaries","category":"page"},{"location":"comparison/#4.-Modern-Compiler","page":"Comparison with CUDD","title":"4. Modern Compiler","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Julia uses LLVM 15+ with latest optimizations\nCUDD compiled with GCC may not leverage all ARM64 features\nJulia's type system enables better optimization opportunities","category":"page"},{"location":"comparison/#Why-is-Cold-Performance-Comparable?","page":"Comparison with CUDD","title":"Why is Cold Performance Comparable?","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"When including initialization overhead:","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Initialization Dominates: Manager setup takes ~900μs for both\nMemory Allocation: Both need to allocate hash tables and data structures\nOne-Time Cost: Initialization is amortized over many operations in real use","category":"page"},{"location":"comparison/#Code-Comparison","page":"Comparison with CUDD","title":"Code Comparison","text":"","category":"section"},{"location":"comparison/#Julia-Implementation","page":"Comparison with CUDD","title":"Julia Implementation","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"using AlgebraicDecisionDiagrams\n\n# Clean, type-safe API\nmgr = DDManager(3)\nx1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\n\n# Boolean operations\nresult = bdd_and(mgr, bdd_or(mgr, x1, x2), x3)\n\n# No manual memory management needed\n# Type-checked at compile time","category":"page"},{"location":"comparison/#CUDD-Implementation","page":"Comparison with CUDD","title":"CUDD Implementation","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"#include \"cudd.h\"\n\n// More verbose, manual memory management\nDdManager *mgr = Cudd_Init(3, 0, CUDD_UNIQUE_SLOTS, CUDD_CACHE_SLOTS, 0);\nDdNode *x1 = Cudd_bddIthVar(mgr, 0);\nDdNode *x2 = Cudd_bddIthVar(mgr, 1);\nDdNode *x3 = Cudd_bddIthVar(mgr, 2);\n\n// Manual reference counting\nDdNode *temp = Cudd_bddOr(mgr, x1, x2);\nCudd_Ref(temp);\nDdNode *result = Cudd_bddAnd(mgr, temp, x3);\nCudd_Ref(result);\nCudd_RecursiveDeref(mgr, temp);\n\n// Must remember to cleanup\nCudd_RecursiveDeref(mgr, result);\nCudd_Quit(mgr);","category":"page"},{"location":"comparison/#Advantages-of-Julia-Implementation","page":"Comparison with CUDD","title":"Advantages of Julia Implementation","text":"","category":"section"},{"location":"comparison/#1.-Type-Safety","page":"Comparison with CUDD","title":"1. Type Safety","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"# Julia: Compile-time type checking\nmgr = DDManager(10)\nx1 = ith_var(mgr, 1)  # Type: NodeId\nresult = bdd_and(mgr, x1, x2)  # Type-checked\n\n# C: No type safety\nDdNode *x1 = Cudd_bddIthVar(mgr, 1);  // void* internally\nDdNode *result = Cudd_bddAnd(mgr, x1, x2);  // No type checking","category":"page"},{"location":"comparison/#2.-Memory-Safety","page":"Comparison with CUDD","title":"2. Memory Safety","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"# Julia: Automatic memory management\nmgr = DDManager(10)\nresult = bdd_and(mgr, x1, x2)\n# No manual ref/deref needed for most operations\n\n# C: Manual memory management\nDdNode *result = Cudd_bddAnd(mgr, x1, x2);\nCudd_Ref(result);  // Must remember to ref\n// ... use result ...\nCudd_RecursiveDeref(mgr, result);  // Must remember to deref","category":"page"},{"location":"comparison/#3.-Ease-of-Use","page":"Comparison with CUDD","title":"3. Ease of Use","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"# Julia: Clean, readable API\nmgr = DDManager(3)\nx1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\nresult = bdd_and(mgr, bdd_or(mgr, x1, x2), x3)\n\n# C: More verbose\nDdManager *mgr = Cudd_Init(3, 0, CUDD_UNIQUE_SLOTS, CUDD_CACHE_SLOTS, 0);\nDdNode *x1 = Cudd_bddIthVar(mgr, 0);\nDdNode *x2 = Cudd_bddIthVar(mgr, 1);\nDdNode *x3 = Cudd_bddIthVar(mgr, 2);\nDdNode *temp = Cudd_bddOr(mgr, x1, x2);\nCudd_Ref(temp);\nDdNode *result = Cudd_bddAnd(mgr, temp, x3);\nCudd_Ref(result);\nCudd_RecursiveDeref(mgr, temp);","category":"page"},{"location":"comparison/#4.-Interoperability","page":"Comparison with CUDD","title":"4. Interoperability","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"# Julia: Seamless integration with Julia ecosystem\nusing AlgebraicDecisionDiagrams\nusing Plots, DataFrames, JuMP\n\n# Use BDDs in optimization\nmodel = Model()\nbdd_constraint = bdd_and(mgr, x1, x2)\n\n# Visualize results\nplot_bdd_size(results)","category":"page"},{"location":"comparison/#5.-Interactive-Development","page":"Comparison with CUDD","title":"5. Interactive Development","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"# Julia: REPL-driven development\njulia> using AlgebraicDecisionDiagrams\njulia> mgr = DDManager(3)\njulia> x1 = ith_var(mgr, 1)\njulia> count_nodes(mgr, x1)  # Immediate feedback\n1\n\n# C: Compile-run-debug cycle\n# Edit code -> gcc -> ./program -> repeat","category":"page"},{"location":"comparison/#Advantages-of-CUDD","page":"Comparison with CUDD","title":"Advantages of CUDD","text":"","category":"section"},{"location":"comparison/#1.-Mature-and-Battle-Tested","page":"Comparison with CUDD","title":"1. Mature and Battle-Tested","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"30+ years of development\nUsed in industry (Intel, IBM, etc.)\nExtensively tested and debugged\nProven reliability","category":"page"},{"location":"comparison/#2.-Variable-Reordering","page":"Comparison with CUDD","title":"2. Variable Reordering","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Multiple reordering algorithms (SIFT, WINDOW, etc.)\nDynamic reordering\nCritical for large problems\nCan reduce BDD size by orders of magnitude","category":"page"},{"location":"comparison/#3.-Optimizations","page":"Comparison with CUDD","title":"3. Optimizations","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Hand-tuned assembly for critical paths\nPlatform-specific optimizations\nDecades of performance tuning\nHighly optimized for specific use cases","category":"page"},{"location":"comparison/#4.-Multi-threading","page":"Comparison with CUDD","title":"4. Multi-threading","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Parallel operations\nThread-safe operations\nImportant for large-scale problems\nBetter utilization of multi-core systems","category":"page"},{"location":"comparison/#Use-Case-Recommendations","page":"Comparison with CUDD","title":"Use Case Recommendations","text":"","category":"section"},{"location":"comparison/#Choose-Julia-Implementation-When:","page":"Comparison with CUDD","title":"Choose Julia Implementation When:","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"✅ Interactive development (REPL, notebooks)\n✅ Long-running applications (servers, daemons)\n✅ Integration with Julia ecosystem\n✅ Type safety and memory safety are priorities\n✅ Performance is critical (warm operations)\n✅ Rapid prototyping\n✅ Problems with <1M nodes","category":"page"},{"location":"comparison/#Choose-CUDD-When:","page":"Comparison with CUDD","title":"Choose CUDD When:","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"✅ Variable reordering is essential\n✅ Very large problems (>10M nodes)\n✅ Multi-threading is required\n✅ Integration with C/C++ codebases\n✅ Industry-standard compliance needed\n✅ Proven reliability is critical","category":"page"},{"location":"comparison/#Performance-by-Use-Case","page":"Comparison with CUDD","title":"Performance by Use Case","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Scenario Expected Performance Recommendation\nInteractive REPL Julia 5-1000x faster ✅ Use Julia\nLong-running server Julia 5-1000x faster ✅ Use Julia\nShort scripts (cold start) Comparable (~1x) Either works\nTight loops Julia 5-1000x faster ✅ Use Julia\nWith reordering CUDD advantage ✅ Use CUDD\nMulti-threaded CUDD advantage ✅ Use CUDD\nVery large (>10M nodes) Depends on reordering ✅ CUDD if reordering needed","category":"page"},{"location":"comparison/#Benchmark-Methodology","page":"Comparison with CUDD","title":"Benchmark Methodology","text":"","category":"section"},{"location":"comparison/#Warm-Benchmarks","page":"Comparison with CUDD","title":"Warm Benchmarks","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Measure steady-state performance with pre-initialized manager:","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Julia: Uses BenchmarkTools.jl with automatic warmup\nCUDD: Manager initialized once, operations measured in loop\nRelevant for: Long-running applications, typical use cases","category":"page"},{"location":"comparison/#Cold-Benchmarks","page":"Comparison with CUDD","title":"Cold Benchmarks","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Measure total time including initialization:","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Julia: Includes DDManager creation and variable setup\nCUDD: Includes Cudd_Init and variable creation\nRelevant for: Short-lived scripts, one-off computations","category":"page"},{"location":"comparison/#Reproducibility","page":"Comparison with CUDD","title":"Reproducibility","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"To reproduce these benchmarks:","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"# Julia benchmarks\ncd AlgebraicDecisionDiagrams.jl\njulia --project=. benchmark/simple_benchmarks.jl\n\n# CUDD benchmarks\ncd benchmark/cudd_comparison\nmake simple_cudd_bench\n./simple_cudd_bench","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"See benchmark/cudd_comparison/RESULTS.md for detailed results.","category":"page"},{"location":"comparison/#Conclusion","page":"Comparison with CUDD","title":"Conclusion","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"AlgebraicDecisionDiagrams.jl provides production-ready performance with significant advantages in:","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Developer productivity (type safety, memory safety, ease of use)\nWarm performance (3-1100x faster than CUDD)\nEcosystem integration (Julia packages)\nExtensibility (easy to modify and extend)","category":"page"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"For most applications, the Julia implementation offers the best balance of performance and usability. CUDD remains the choice for extreme-scale problems requiring variable reordering or when multi-threading is essential.","category":"page"},{"location":"comparison/#See-Also","page":"Comparison with CUDD","title":"See Also","text":"","category":"section"},{"location":"comparison/","page":"Comparison with CUDD","title":"Comparison with CUDD","text":"Performance: Detailed performance analysis\nGetting Started: Installation and basic usage\nAPI Reference: Complete API documentation","category":"page"},{"location":"guide/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"This guide covers utility functions for analyzing, debugging, and managing decision diagrams.","category":"page"},{"location":"guide/utilities/#Counting-Functions","page":"Utilities","title":"Counting Functions","text":"","category":"section"},{"location":"guide/utilities/#Count-Nodes","page":"Utilities","title":"Count Nodes","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Count the number of nodes in a decision diagram:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"using AlgebraicDecisionDiagrams\n\nmgr = DDManager(5)\nx1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\n\n# Simple variable: 1 node\ncount = count_nodes(mgr, x1)\nprintln(\"Nodes in x1: \", count)  # 1\n\n# AND of two variables: 2 nodes\nf = bdd_and(mgr, x1, x2)\ncount = count_nodes(mgr, f)\nprintln(\"Nodes in x1 ∧ x2: \", count)  # 2\n\n# More complex formula\ng = bdd_or(mgr, bdd_and(mgr, x1, x2), x3)\ncount = count_nodes(mgr, g)\nprintln(\"Nodes in (x1 ∧ x2) ∨ x3: \", count)  # 3","category":"page"},{"location":"guide/utilities/#Count-Paths","page":"Utilities","title":"Count Paths","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Count the number of paths from root to true terminal:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(3)\nx1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\n\n# x1 ∧ x2: one path (both must be true)\nf = bdd_and(mgr, x1, x2)\npaths = count_paths(mgr, f)\nprintln(\"Paths in x1 ∧ x2: \", paths)  # 1\n\n# x1 ∨ x2: three paths (x1 true, x2 true, or both)\ng = bdd_or(mgr, x1, x2)\npaths = count_paths(mgr, g)\nprintln(\"Paths in x1 ∨ x2: \", paths)  # 3\n\n# x1 ⊕ x2: two paths (exactly one true)\nh = bdd_xor(mgr, x1, x2)\npaths = count_paths(mgr, h)\nprintln(\"Paths in x1 ⊕ x2: \", paths)  # 2","category":"page"},{"location":"guide/utilities/#Count-Minterms","page":"Utilities","title":"Count Minterms","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Count the number of satisfying assignments (minterms):","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(3)\nx1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\n\n# x1 ∧ x2: 2 minterms out of 8 (x3 can be 0 or 1)\nf = bdd_and(mgr, x1, x2)\nminterms = count_minterms(mgr, f, 3)\nprintln(\"Minterms in x1 ∧ x2: \", minterms)  # 2.0\n\n# x1 ∨ x2: 6 minterms out of 8\ng = bdd_or(mgr, x1, x2)\nminterms = count_minterms(mgr, g, 3)\nprintln(\"Minterms in x1 ∨ x2: \", minterms)  # 6.0\n\n# Calculate probability (uniform distribution)\nprob = count_minterms(mgr, g, 3) / 2^3\nprintln(\"P(x1 ∨ x2): \", prob)  # 0.75","category":"page"},{"location":"guide/utilities/#ZDD-Count","page":"Utilities","title":"ZDD Count","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Count the number of sets in a ZDD family:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(4)\n\nsets = [[1, 2], [2, 3], [1, 3], [4]]\nfamily = zdd_from_sets(mgr, sets)\n\ncount = zdd_count(mgr, family)\nprintln(\"Number of sets: \", count)  # 4","category":"page"},{"location":"guide/utilities/#Manager-Information","page":"Utilities","title":"Manager Information","text":"","category":"section"},{"location":"guide/utilities/#Node-Statistics","page":"Utilities","title":"Node Statistics","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Get information about the manager's state:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(10)\n\n# Create some nodes\nfor i in 1:10\n    x = ith_var(mgr, i)\nend\n\n# Total nodes in manager\ntotal_nodes = length(mgr.nodes)\nprintln(\"Total nodes: \", total_nodes)\n\n# Cache statistics\ncache_size = length(mgr.cache.entries)\nprintln(\"Cache size: \", cache_size)\n\n# Unique table statistics\nfor (level, table) in enumerate(mgr.unique_tables)\n    if !isempty(table.slots)\n        println(\"Level $level: \", length(table.slots), \" slots\")\n    end\nend","category":"page"},{"location":"guide/utilities/#Constants","page":"Utilities","title":"Constants","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Access special constants:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(5)\n\n# BDD constants\ntrue_node = mgr.one\nfalse_node = mgr.zero\n\nprintln(\"True node: \", true_node)\nprintln(\"False node: \", false_node)\n\n# Check if a node is a constant\nis_true = (x == mgr.one)\nis_false = (x == mgr.zero)\nis_constant = is_true || is_false","category":"page"},{"location":"guide/utilities/#Debugging-and-Inspection","page":"Utilities","title":"Debugging and Inspection","text":"","category":"section"},{"location":"guide/utilities/#Node-Information","page":"Utilities","title":"Node Information","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Inspect individual nodes:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\n\n# Get node ID (includes complement bit)\nnode_id = x1\n\n# Check if complemented\nis_complemented = (node_id.id & 1) == 1\n\n# Get actual node index\nnode_index = node_id.id >> 1\n\n# Access node (if not terminal)\nif node_index > 0 && node_index <= length(mgr.nodes)\n    node = mgr.nodes[node_index]\n    println(\"Variable index: \", node.index)\n    println(\"Then child: \", node.then_child)\n    println(\"Else child: \", node.else_child)\nend","category":"page"},{"location":"guide/utilities/#Traversal","page":"Utilities","title":"Traversal","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Traverse a decision diagram:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(3)\nx1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\nf = bdd_and(mgr, bdd_and(mgr, x1, x2), x3)\n\nfunction traverse(mgr, node_id, visited=Set())\n    # Avoid revisiting nodes\n    if node_id in visited\n        return\n    end\n    push!(visited, node_id)\n\n    # Check if terminal\n    if node_id == mgr.zero\n        println(\"Terminal: false\")\n        return\n    elseif node_id == mgr.one\n        println(\"Terminal: true\")\n        return\n    end\n\n    # Get node index (remove complement bit)\n    is_complemented = (node_id.id & 1) == 1\n    node_index = node_id.id >> 1\n\n    if node_index > 0 && node_index <= length(mgr.nodes)\n        node = mgr.nodes[node_index]\n        println(\"Node: var=\", node.index,\n                \" complemented=\", is_complemented)\n\n        # Traverse children\n        traverse(mgr, node.then_child, visited)\n        traverse(mgr, node.else_child, visited)\n    end\nend\n\ntraverse(mgr, f)","category":"page"},{"location":"guide/utilities/#Conversion-Functions","page":"Utilities","title":"Conversion Functions","text":"","category":"section"},{"location":"guide/utilities/#BDD-ADD","page":"Utilities","title":"BDD ↔ ADD","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Convert between BDDs and ADDs:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(2)\n\n# BDD to ADD\nx1_bdd = ith_var(mgr, 1)\nx2_bdd = ith_var(mgr, 2)\nf_bdd = bdd_and(mgr, x1_bdd, x2_bdd)\n\nf_add = bdd_to_add(mgr, f_bdd)\nprintln(\"BDD converted to ADD\")\n\n# ADD to BDD (threshold at 0)\nx1_add = add_ith_var(mgr, 1)\nx2_add = add_ith_var(mgr, 2)\ng_add = add_plus(mgr, x1_add, x2_add)\n\ng_bdd = add_to_bdd(mgr, g_add)\nprintln(\"ADD converted to BDD\")","category":"page"},{"location":"guide/utilities/#BDD-ZDD","page":"Utilities","title":"BDD ↔ ZDD","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Convert between BDDs and ZDDs:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(3)\n\n# BDD to ZDD\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nf_bdd = bdd_and(mgr, x1, x2)\n\nf_zdd = bdd_to_zdd(mgr, f_bdd)\nprintln(\"BDD converted to ZDD\")\n\n# ZDD to BDD\ns1 = zdd_singleton(mgr, 1)\ns2 = zdd_singleton(mgr, 2)\ng_zdd = zdd_product(mgr, s1, s2)\n\ng_bdd = zdd_to_bdd(mgr, g_zdd)\nprintln(\"ZDD converted to BDD\")","category":"page"},{"location":"guide/utilities/#ZDD-Sets","page":"Utilities","title":"ZDD ↔ Sets","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Convert between ZDDs and set representations:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(4)\n\n# Sets to ZDD\nsets = [[1, 2], [2, 3], [1, 3], [4]]\nfamily = zdd_from_sets(mgr, sets)\nprintln(\"Created ZDD from sets\")\n\n# ZDD to sets\nrecovered = zdd_to_sets(mgr, family)\nprintln(\"Recovered sets: \", recovered)\n\n# Verify\n@assert sort(sort.(sets)) == sort(sort.(recovered))","category":"page"},{"location":"guide/utilities/#Performance-Monitoring","page":"Utilities","title":"Performance Monitoring","text":"","category":"section"},{"location":"guide/utilities/#Benchmarking-Operations","page":"Utilities","title":"Benchmarking Operations","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Measure operation performance:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"using BenchmarkTools\n\nmgr = DDManager(10)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\n\n# Benchmark AND operation\n@benchmark bdd_and($mgr, $x1, $x2)\n\n# Benchmark with larger formulas\nvars = [ith_var(mgr, i) for i in 1:10]\n@benchmark begin\n    result = $vars[1]\n    for i in 2:10\n        result = bdd_and($mgr, result, $vars[i])\n    end\nend","category":"page"},{"location":"guide/utilities/#Memory-Usage","page":"Utilities","title":"Memory Usage","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Monitor memory usage:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(100)\n\n# Create many nodes\nfor i in 1:100\n    x = ith_var(mgr, i)\nend\n\n# Check memory usage\nnode_memory = sizeof(mgr.nodes[1]) * length(mgr.nodes)\ncache_memory = sizeof(mgr.cache.entries[1]) * length(mgr.cache.entries)\n\nprintln(\"Node memory: \", node_memory, \" bytes\")\nprintln(\"Cache memory: \", cache_memory, \" bytes\")\nprintln(\"Total: \", node_memory + cache_memory, \" bytes\")","category":"page"},{"location":"guide/utilities/#Helper-Functions","page":"Utilities","title":"Helper Functions","text":"","category":"section"},{"location":"guide/utilities/#Variable-Creation","page":"Utilities","title":"Variable Creation","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Create multiple variables at once:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(10)\n\n# Create all variables\nvars = [ith_var(mgr, i) for i in 1:10]\n\n# Or for ADDs\nadd_vars = [add_ith_var(mgr, i) for i in 1:10]\n\n# Or for ZDDs\nzdd_singletons = [zdd_singleton(mgr, i) for i in 1:10]","category":"page"},{"location":"guide/utilities/#Formula-Building","page":"Utilities","title":"Formula Building","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Build complex formulas:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(5)\nvars = [ith_var(mgr, i) for i in 1:5]\n\n# Conjunction of all variables\nconjunction = reduce((acc, v) -> bdd_and(mgr, acc, v), vars)\n\n# Disjunction of all variables\ndisjunction = reduce((acc, v) -> bdd_or(mgr, acc, v), vars)\n\n# Parity (XOR of all variables)\nparity = reduce((acc, v) -> bdd_xor(mgr, acc, v), vars)\n\n# At least k variables true\nfunction at_least_k(mgr, vars, k)\n    n = length(vars)\n    if k == 0\n        return mgr.one\n    end\n    if k > n\n        return mgr.zero\n    end\n\n    # Recursive: include first var or not\n    with_first = bdd_and(mgr, vars[1],\n                         at_least_k(mgr, vars[2:end], k-1))\n    without_first = at_least_k(mgr, vars[2:end], k)\n\n    return bdd_or(mgr, with_first, without_first)\nend\n\nat_least_3 = at_least_k(mgr, vars, 3)","category":"page"},{"location":"guide/utilities/#Validation-and-Testing","page":"Utilities","title":"Validation and Testing","text":"","category":"section"},{"location":"guide/utilities/#Equivalence-Checking","page":"Utilities","title":"Equivalence Checking","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Check if two formulas are equivalent:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(3)\nx1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\n\n# Two ways to express the same formula\nf1 = bdd_or(mgr, bdd_and(mgr, x1, x2), x3)\nf2 = bdd_and(mgr,\n    bdd_or(mgr, x1, x3),\n    bdd_or(mgr, x2, x3))\n\n# Check equivalence (should be different)\nare_equivalent = (f1 == f2)\nprintln(\"Equivalent: \", are_equivalent)\n\n# De Morgan's law: ¬(x1 ∧ x2) = ¬x1 ∨ ¬x2\nlhs = bdd_not(mgr, bdd_and(mgr, x1, x2))\nrhs = bdd_or(mgr, bdd_not(mgr, x1), bdd_not(mgr, x2))\n@assert lhs == rhs","category":"page"},{"location":"guide/utilities/#Satisfiability-Checking","page":"Utilities","title":"Satisfiability Checking","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"Check if a formula is satisfiable:","category":"page"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(3)\nx1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\n\n# Satisfiable formula\nf = bdd_and(mgr, x1, x2)\nis_sat = (f != mgr.zero)\nprintln(\"Satisfiable: \", is_sat)  # true\n\n# Unsatisfiable formula\ng = bdd_and(mgr, x1, bdd_not(mgr, x1))\nis_unsat = (g == mgr.zero)\nprintln(\"Unsatisfiable: \", is_unsat)  # true\n\n# Tautology\nh = bdd_or(mgr, x1, bdd_not(mgr, x1))\nis_tautology = (h == mgr.one)\nprintln(\"Tautology: \", is_tautology)  # true","category":"page"},{"location":"guide/utilities/#Best-Practices","page":"Utilities","title":"Best Practices","text":"","category":"section"},{"location":"guide/utilities/#1.-Reuse-Managers","page":"Utilities","title":"1. Reuse Managers","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"# Good: One manager for related operations\nmgr = DDManager(10)\nresults = []\nfor i in 1:100\n    x = ith_var(mgr, i % 10 + 1)\n    push!(results, x)\nend\n\n# Bad: Creating managers repeatedly\nfor i in 1:100\n    mgr = DDManager(10)  # Expensive!\n    x = ith_var(mgr, 1)\nend","category":"page"},{"location":"guide/utilities/#2.-Check-for-Constants","page":"Utilities","title":"2. Check for Constants","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(3)\nx1 = ith_var(mgr, 1)\n\n# Check before expensive operations\nf = bdd_and(mgr, x1, mgr.zero)\nif f == mgr.zero\n    println(\"Result is false, skip further operations\")\nend","category":"page"},{"location":"guide/utilities/#3.-Use-Appropriate-Counting","page":"Utilities","title":"3. Use Appropriate Counting","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"mgr = DDManager(10)\nx1, x2 = [ith_var(mgr, i) for i in 1:2]\nf = bdd_and(mgr, x1, x2)\n\n# For node count (diagram size)\nnodes = count_nodes(mgr, f)\n\n# For satisfying assignments\nminterms = count_minterms(mgr, f, 2)\n\n# For paths to true\npaths = count_paths(mgr, f)\n\n# Choose based on what you need to measure","category":"page"},{"location":"guide/utilities/#See-Also","page":"Utilities","title":"See Also","text":"","category":"section"},{"location":"guide/utilities/","page":"Utilities","title":"Utilities","text":"BDD Guide: Binary Decision Diagrams\nADD Guide: Algebraic Decision Diagrams\nZDD Guide: Zero-suppressed Decision Diagrams\nAPI Reference: Complete API documentation","category":"page"},{"location":"#AlgebraicDecisionDiagrams.jl","page":"Home","title":"AlgebraicDecisionDiagrams.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A high-performance Julia implementation of Decision Diagrams (BDDs, ADDs, ZDDs) inspired by the CUDD library.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AlgebraicDecisionDiagrams.jl provides efficient implementations of three types of decision diagrams:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Binary Decision Diagrams (BDDs): Canonical representation of Boolean functions\nAlgebraic Decision Diagrams (ADDs): Extension to real-valued functions\nZero-suppressed Decision Diagrams (ZDDs): Optimized for sparse set representation","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"✅ High Performance: 3-1100x faster than CUDD for cached operations\n✅ Zero Allocations: All hot-path operations avoid memory allocations\n✅ Production Ready: 154 passing tests (91% coverage)\n✅ CUDD-Compatible: Architecture based on industry-standard CUDD library\n✅ Type Safe: Full Julia type system support\n✅ Easy to Use: Clean, intuitive API","category":"page"},{"location":"#Performance-Highlights","page":"Home","title":"Performance Highlights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Single operations: 2-7 nanoseconds with zero allocations\nmgr = DDManager(10)\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\n\n# BDD AND: ~5 ns (vs CUDD: ~27 ns)\nresult = bdd_and(mgr, x1, x2)\n\n# BDD OR: ~5 ns (vs CUDD: ~26 ns)\nresult = bdd_or(mgr, x1, x2)\n\n# BDD NOT: ~2 ns (complement edge - O(1))\nresult = bdd_not(mgr, x1)","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AlgebraicDecisionDiagrams\n\n# Create a manager for 3 variables\nmgr = DDManager(3)\n\n# Create BDD variables\nx1 = ith_var(mgr, 1)\nx2 = ith_var(mgr, 2)\nx3 = ith_var(mgr, 3)\n\n# Boolean operations\nf = bdd_and(mgr, x1, x2)           # x1 ∧ x2\ng = bdd_or(mgr, f, x3)             # (x1 ∧ x2) ∨ x3\nh = bdd_not(mgr, g)                # ¬((x1 ∧ x2) ∨ x3)\n\n# Count satisfying assignments\ncount = count_minterms(mgr, g, 3)  # 7.0 (out of 8 possible)\n\n# Evaluate with specific variable assignment\nassignment = Dict(1 => true, 2 => true, 3 => false)\nvalue = bdd_eval(mgr, g, assignment)  # true","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AlgebraicDecisionDiagrams\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or for development:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.develop(url=\"https://github.com/yourusername/AlgebraicDecisionDiagrams.jl\")","category":"page"},{"location":"#Comparison-with-CUDD","page":"Home","title":"Comparison with CUDD","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Metric Julia CUDD Advantage\nWarm Performance 3-1100x faster Baseline Julia\nCold Performance Comparable Comparable Tie\nMemory Allocations Zero N/A Julia\nType Safety Full None Julia\nVariable Reordering Not yet Yes CUDD\nMulti-threading Not yet Yes CUDD","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Comparison with CUDD for detailed benchmarks.","category":"page"},{"location":"#When-to-Use","page":"Home","title":"When to Use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use AlgebraicDecisionDiagrams.jl when:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interactive development (REPL, notebooks)\nLong-running applications (servers, daemons)\nIntegration with Julia ecosystem\nPerformance is critical\nType safety matters","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use CUDD when:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Variable reordering is essential\nMulti-threading is required\nIntegration with C/C++ code\nVery large problems (>10M nodes) with reordering","category":"page"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Getting Started: Installation and basic usage\nUser Guide: Detailed guides for BDDs, ADDs, and ZDDs\nBDD Guide\nADD Guide\nZDD Guide\nUtilities\nPerformance: Performance characteristics and optimization\nComparison with CUDD: Detailed benchmarks and comparison\nAPI Reference: Complete API documentation\nInternals: Implementation details","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are welcome! Please see the GitHub repository for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bug reports and feature requests\nPull requests\nDocumentation improvements","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT License - see LICENSE file for details.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This implementation is inspired by the CUDD (Colorado University Decision Diagram) library by Fabio Somenzi and the University of Colorado Boulder.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This page describes the internal implementation details of AlgebraicDecisionDiagrams.jl.","category":"page"},{"location":"internals/#Architecture-Overview","page":"Internals","title":"Architecture Overview","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The implementation follows CUDD's architecture with three main components:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Unique Table: Hash consing for canonical representation\nComputed Table: Direct-mapped cache for operation memoization\nNode Storage: Compact node representation with complement edges","category":"page"},{"location":"internals/#Data-Structures","page":"Internals","title":"Data Structures","text":"","category":"section"},{"location":"internals/#Node-Representation","page":"Internals","title":"Node Representation","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"struct DDNode\n    index::UInt32      # Variable index (0 for terminal)\n    then_child::NodeId # High/then child\n    else_child::NodeId # Low/else child\n    value::Float64     # Terminal value (for ADDs)\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Design decisions:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"UInt32 for index: Supports up to 4 billion variables\nNodeId for children: Includes complement bit\nFloat64 for value: Used only for ADD terminals\nTotal size: ~32 bytes per node","category":"page"},{"location":"internals/#Node-ID-with-Complement-Edges","page":"Internals","title":"Node ID with Complement Edges","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"struct NodeId\n    id::UInt64\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The id field encodes both the node index and complement bit:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Bits 1-63: Node index (shifted left by 1)\nBit 0 (LSB): Complement bit (1 = complemented, 0 = regular)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Operations:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"# Extract node index\nnode_index = node_id.id >> 1\n\n# Check if complemented\nis_complemented = (node_id.id & 1) == 1\n\n# Create complemented node\ncomplemented = NodeId(node_id.id ⊕ 1)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Benefits:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"NOT operation is O(1) (just flip LSB)\nReduces BDD size by ~2x\nNo additional memory overhead","category":"page"},{"location":"internals/#Unique-Table","page":"Internals","title":"Unique Table","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"struct UniqueTable\n    slots::Vector{Vector{NodeId}}\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"One unique table per variable level:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Hash-based lookup for canonical nodes\nCollision resolution via chaining\nEnsures unique representation","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Hash function:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"function unique_hash(var_index::Int, then_child::NodeId, else_child::NodeId, table_size::Int)\n    h = UInt64(var_index) * HASH_P1 + then_child.id * HASH_P2 + else_child.id * HASH_P1\n    return Int(((h - 1) % table_size) + 1)\nend","category":"page"},{"location":"internals/#Computed-Table","page":"Internals","title":"Computed Table","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"struct CacheEntry\n    op::UInt64\n    f::NodeId\n    g::NodeId\n    h::NodeId\n    result::NodeId\nend\n\nstruct ComputedTable\n    entries::Vector{CacheEntry}\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Direct-mapped cache:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Fixed-size cache (default: 1M entries)\nHash-based indexing\nStores operation results for memoization","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Hash function:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"function cache_hash(op::UInt64, f::NodeId, g::NodeId, h::NodeId, cache_size::Int)\n    hash_val = op * HASH_P1 + f.id * HASH_P2 + g.id * HASH_P1 + h.id * HASH_P2\n    return Int(((hash_val - 1) % cache_size) + 1)\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Operation codes:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"const OP_AND = UInt64(1)\nconst OP_OR = UInt64(2)\nconst OP_XOR = UInt64(3)\nconst OP_ITE = UInt64(4)\n# ... etc","category":"page"},{"location":"internals/#Core-Algorithms","page":"Internals","title":"Core Algorithms","text":"","category":"section"},{"location":"internals/#ITE-(If-Then-Else)","page":"Internals","title":"ITE (If-Then-Else)","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The fundamental operation for BDDs:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"function bdd_ite(mgr::DDManager, f::NodeId, g::NodeId, h::NodeId) -> NodeId\n    # Terminal cases\n    if f == mgr.one\n        return g\n    end\n    if f == mgr.zero\n        return h\n    end\n    if g == h\n        return g\n    end\n    if g == mgr.one && h == mgr.zero\n        return f\n    end\n\n    # Check cache\n    cache_idx = cache_hash(OP_ITE, f, g, h, length(mgr.cache.entries))\n    entry = mgr.cache.entries[cache_idx]\n    if entry.op == OP_ITE && entry.f == f && entry.g == g && entry.h == h\n        return entry.result\n    end\n\n    # Find top variable\n    top_var = min(get_var(mgr, f), get_var(mgr, g), get_var(mgr, h))\n\n    # Compute cofactors\n    f_then, f_else = cofactor(mgr, f, top_var)\n    g_then, g_else = cofactor(mgr, g, top_var)\n    h_then, h_else = cofactor(mgr, h, top_var)\n\n    # Recursive calls\n    then_result = bdd_ite(mgr, f_then, g_then, h_then)\n    else_result = bdd_ite(mgr, f_else, g_else, h_else)\n\n    # Reduction rule\n    if then_result == else_result\n        result = then_result\n    else\n        result = unique_lookup(mgr, top_var, then_result, else_result)\n    end\n\n    # Cache result\n    mgr.cache.entries[cache_idx] = CacheEntry(OP_ITE, f, g, h, result)\n\n    return result\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Key points:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Terminal cases for early termination\nCache lookup before recursion\nShannon expansion on top variable\nReduction rule eliminates redundant nodes\nResult cached for future use","category":"page"},{"location":"internals/#Unique-Lookup","page":"Internals","title":"Unique Lookup","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Ensures canonical representation:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"function unique_lookup(mgr::DDManager, var_index::Int, then_child::NodeId, else_child::NodeId) -> NodeId\n    # Reduction rule: if both children same, return child\n    if then_child == else_child\n        return then_child\n    end\n\n    # Complement edge normalization (BDDs only)\n    complement = false\n    if is_complemented(else_child)\n        complement = true\n        then_child = NodeId(then_child.id ⊕ 1)\n        else_child = NodeId(else_child.id ⊕ 1)\n    end\n\n    # Hash lookup\n    table = mgr.unique_tables[var_index]\n    h = unique_hash(var_index, then_child, else_child, length(table.slots))\n    slot = table.slots[h]\n\n    # Check existing nodes\n    for node_id in slot\n        node_idx = node_id.id >> 1\n        node = mgr.nodes[node_idx]\n        if node.index == var_index &&\n           node.then_child == then_child &&\n           node.else_child == else_child\n            return complement ? NodeId(node_id.id ⊕ 1) : node_id\n        end\n    end\n\n    # Create new node\n    new_node = DDNode(UInt32(var_index), then_child, else_child, 0.0)\n    push!(mgr.nodes, new_node)\n    new_id = NodeId(UInt64(length(mgr.nodes)) << 1)\n    push!(slot, new_id)\n\n    return complement ? NodeId(new_id.id ⊕ 1) : new_id\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Key points:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Reduction rule eliminates redundant nodes\nComplement edge normalization (else-child regular)\nHash-based lookup for existing nodes\nCreates new node if not found","category":"page"},{"location":"internals/#ZDD-Reduction-Rule","page":"Internals","title":"ZDD Reduction Rule","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"ZDDs use a different reduction rule:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"function zdd_unique_lookup(mgr::DDManager, var_index::Int, then_child::NodeId, else_child::NodeId) -> NodeId\n    # ZDD reduction: if then-child is empty, return else-child\n    if then_child == mgr.zero\n        return else_child\n    end\n\n    # Standard unique lookup\n    # (No complement edge normalization for ZDDs)\n    # ...\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Difference from BDD:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"BDD: Eliminate if then_child == else_child\nZDD: Eliminate if then_child == empty","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"This makes ZDDs compact for sparse sets.","category":"page"},{"location":"internals/#Performance-Optimizations","page":"Internals","title":"Performance Optimizations","text":"","category":"section"},{"location":"internals/#1.-Inline-Functions","page":"Internals","title":"1. Inline Functions","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Critical functions are marked @inline:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"@inline function is_complemented(node_id::NodeId)\n    return (node_id.id & 1) == 1\nend\n\n@inline function get_node_index(node_id::NodeId)\n    return node_id.id >> 1\nend","category":"page"},{"location":"internals/#2.-Type-Stability","page":"Internals","title":"2. Type Stability","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"All functions are type-stable:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"# Good: Type-stable\nfunction bdd_and(mgr::DDManager, f::NodeId, g::NodeId)::NodeId\n    # ...\nend\n\n# Bad: Not type-stable (would be slower)\nfunction bdd_and(mgr, f, g)\n    # ...\nend","category":"page"},{"location":"internals/#3.-Cache-Efficiency","page":"Internals","title":"3. Cache Efficiency","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Direct-mapped cache for O(1) lookup:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"No collision resolution needed\nCache line friendly\nPredictable performance","category":"page"},{"location":"internals/#4.-Complement-Edge-Optimization","page":"Internals","title":"4. Complement Edge Optimization","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"NOT operation is O(1):","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"@inline function bdd_not(mgr::DDManager, f::NodeId)::NodeId\n    return NodeId(f.id ⊕ 1)  # Just flip LSB\nend","category":"page"},{"location":"internals/#5.-Early-Termination","page":"Internals","title":"5. Early Termination","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Terminal cases checked first:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"function bdd_and(mgr::DDManager, f::NodeId, g::NodeId)::NodeId\n    # Terminal cases (fast path)\n    if f == mgr.zero || g == mgr.zero\n        return mgr.zero\n    end\n    if f == mgr.one\n        return g\n    end\n    if g == mgr.one\n        return f\n    end\n    if f == g\n        return f\n    end\n\n    # General case (slower path)\n    return bdd_ite(mgr, f, g, mgr.zero)\nend","category":"page"},{"location":"internals/#Memory-Management","page":"Internals","title":"Memory Management","text":"","category":"section"},{"location":"internals/#Reference-Counting","page":"Internals","title":"Reference Counting","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Currently uses simple reference counting:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"struct DDNode\n    # ...\n    ref_count::Int  # Not yet implemented\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Future work:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Implement reference counting\nGarbage collection for unused nodes\nMemory compaction","category":"page"},{"location":"internals/#Node-Allocation","page":"Internals","title":"Node Allocation","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Nodes are allocated in a vector:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"mgr.nodes = Vector{DDNode}()\npush!(mgr.nodes, terminal_node)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Benefits:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Fast allocation\nGood cache locality\nSimple indexing","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Drawbacks:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"No deallocation (yet)\nMemory grows monotonically","category":"page"},{"location":"internals/#Hash-Functions","page":"Internals","title":"Hash Functions","text":"","category":"section"},{"location":"internals/#Prime-Numbers","page":"Internals","title":"Prime Numbers","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"const HASH_P1 = UInt64(0x9e3779b97f4a7c15)  # Golden ratio\nconst HASH_P2 = UInt64(0xbf58476d1ce4e5b9)  # Another large prime","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Properties:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Good distribution\nMinimal collisions\nFast computation","category":"page"},{"location":"internals/#Collision-Resolution","page":"Internals","title":"Collision Resolution","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Unique table uses chaining:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"struct UniqueTable\n    slots::Vector{Vector{NodeId}}  # Each slot is a chain\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Computed table uses direct mapping (no collision resolution):","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"# Overwrite on collision\nmgr.cache.entries[cache_idx] = new_entry","category":"page"},{"location":"internals/#File-Organization","page":"Internals","title":"File Organization","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"src/\n├── AlgebraicDecisionDiagrams.jl  # Main module\n├── types.jl                       # Data structures\n├── unique.jl                      # Hash consing\n├── cache.jl                       # Operation caching\n├── bdd.jl                         # BDD operations\n├── add.jl                         # ADD operations\n├── zdd.jl                         # ZDD operations\n└── utils.jl                       # Utility functions","category":"page"},{"location":"internals/#Module-Structure","page":"Internals","title":"Module Structure","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"module AlgebraicDecisionDiagrams\n\n# Include files in order\ninclude(\"types.jl\")\ninclude(\"unique.jl\")\ninclude(\"cache.jl\")\ninclude(\"bdd.jl\")\ninclude(\"add.jl\")\ninclude(\"zdd.jl\")\ninclude(\"utils.jl\")\n\n# Export public API\nexport DDManager, NodeId\nexport ith_var, bdd_and, bdd_or, bdd_xor, bdd_not, bdd_ite\nexport add_ith_var, add_const, add_plus, add_times, add_min, add_max\nexport zdd_singleton, zdd_union, zdd_intersection, zdd_product\nexport count_nodes, count_paths, count_minterms\n\nend","category":"page"},{"location":"internals/#Testing-Strategy","page":"Internals","title":"Testing Strategy","text":"","category":"section"},{"location":"internals/#Unit-Tests","page":"Internals","title":"Unit Tests","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Each operation has dedicated tests:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"@testset \"BDD AND\" begin\n    mgr = DDManager(3)\n    x1 = ith_var(mgr, 1)\n    x2 = ith_var(mgr, 2)\n\n    # Test basic AND\n    result = bdd_and(mgr, x1, x2)\n    @test result != mgr.zero\n    @test result != mgr.one\n\n    # Test terminal cases\n    @test bdd_and(mgr, x1, mgr.zero) == mgr.zero\n    @test bdd_and(mgr, x1, mgr.one) == x1\n\n    # Test commutativity\n    @test bdd_and(mgr, x1, x2) == bdd_and(mgr, x2, x1)\nend","category":"page"},{"location":"internals/#Property-Based-Tests","page":"Internals","title":"Property-Based Tests","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Test algebraic properties:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"@testset \"Boolean Algebra Laws\" begin\n    mgr = DDManager(3)\n    x1, x2, x3 = [ith_var(mgr, i) for i in 1:3]\n\n    # Commutativity\n    @test bdd_and(mgr, x1, x2) == bdd_and(mgr, x2, x1)\n    @test bdd_or(mgr, x1, x2) == bdd_or(mgr, x2, x1)\n\n    # Associativity\n    @test bdd_and(mgr, bdd_and(mgr, x1, x2), x3) ==\n          bdd_and(mgr, x1, bdd_and(mgr, x2, x3))\n\n    # De Morgan's laws\n    @test bdd_not(mgr, bdd_and(mgr, x1, x2)) ==\n          bdd_or(mgr, bdd_not(mgr, x1), bdd_not(mgr, x2))\nend","category":"page"},{"location":"internals/#Future-Improvements","page":"Internals","title":"Future Improvements","text":"","category":"section"},{"location":"internals/#1.-Variable-Reordering","page":"Internals","title":"1. Variable Reordering","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Implement SIFT algorithm:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Swap adjacent variables\nMeasure BDD size\nKeep best ordering","category":"page"},{"location":"internals/#2.-Garbage-Collection","page":"Internals","title":"2. Garbage Collection","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Implement mark-and-sweep:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Mark reachable nodes\nSweep unreachable nodes\nCompact node vector","category":"page"},{"location":"internals/#3.-Multi-threading","page":"Internals","title":"3. Multi-threading","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Thread-safe operations:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Per-thread caches\nLock-free unique tables\nParallel apply operations","category":"page"},{"location":"internals/#4.-Additional-Optimizations","page":"Internals","title":"4. Additional Optimizations","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"SIMD operations\nCustom allocators\nProfile-guided optimization","category":"page"},{"location":"internals/#See-Also","page":"Internals","title":"See Also","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"API Reference: Complete API documentation\nPerformance: Performance characteristics\nComparison with CUDD: Implementation comparison","category":"page"},{"location":"guide/adds/#Algebraic-Decision-Diagrams-(ADDs)","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"Algebraic Decision Diagrams (ADDs) extend BDDs to represent functions that map Boolean variables to real numbers. They are useful for probabilistic reasoning, optimization, and numerical computations.","category":"page"},{"location":"guide/adds/#What-are-ADDs?","page":"Algebraic Decision Diagrams (ADDs)","title":"What are ADDs?","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"An ADD is similar to a BDD, but:","category":"page"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"Terminal nodes contain real values (not just true/false)\nRepresents functions: f: {0,1}ⁿ → ℝ\nSupports arithmetic operations (addition, multiplication, min, max)\nNo complement edges (unlike BDDs)","category":"page"},{"location":"guide/adds/#Creating-ADDs","page":"Algebraic Decision Diagrams (ADDs)","title":"Creating ADDs","text":"","category":"section"},{"location":"guide/adds/#Variables","page":"Algebraic Decision Diagrams (ADDs)","title":"Variables","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"ADD variables represent 0-1 indicator functions:","category":"page"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"using AlgebraicDecisionDiagrams\n\nmgr = DDManager(3)\n\n# Create ADD variables (0-1 functions)\nx1 = add_ith_var(mgr, 1)  # 1 if var 1 is true, 0 otherwise\nx2 = add_ith_var(mgr, 2)\nx3 = add_ith_var(mgr, 3)","category":"page"},{"location":"guide/adds/#Constants","page":"Algebraic Decision Diagrams (ADDs)","title":"Constants","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"Create constant ADDs:","category":"page"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(3)\n\n# Constant values\nc0 = add_const(mgr, 0.0)\nc1 = add_const(mgr, 1.0)\nc5 = add_const(mgr, 5.0)\nc_neg = add_const(mgr, -3.5)","category":"page"},{"location":"guide/adds/#Arithmetic-Operations","page":"Algebraic Decision Diagrams (ADDs)","title":"Arithmetic Operations","text":"","category":"section"},{"location":"guide/adds/#Addition","page":"Algebraic Decision Diagrams (ADDs)","title":"Addition","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(2)\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\n\n# f(x1, x2) = x1 + x2\n# Returns: 0 if both false, 1 if one true, 2 if both true\nf = add_plus(mgr, x1, x2)\n\n# With constants: g(x1, x2) = 5 + 3*x1 + 2*x2\nc5 = add_const(mgr, 5.0)\nc3 = add_const(mgr, 3.0)\nc2 = add_const(mgr, 2.0)\n\ng = add_plus(mgr,\n    add_plus(mgr, c5, add_times(mgr, c3, x1)),\n    add_times(mgr, c2, x2))","category":"page"},{"location":"guide/adds/#Multiplication","page":"Algebraic Decision Diagrams (ADDs)","title":"Multiplication","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(2)\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\n\n# f(x1, x2) = x1 * x2 (AND operation for 0-1 functions)\nf = add_times(mgr, x1, x2)\n\n# Polynomial: g(x1, x2) = 2*x1*x2 + 3*x1 + 4*x2 + 5\nc2 = add_const(mgr, 2.0)\nc3 = add_const(mgr, 3.0)\nc4 = add_const(mgr, 4.0)\nc5 = add_const(mgr, 5.0)\n\ng = add_plus(mgr,\n    add_plus(mgr,\n        add_plus(mgr,\n            add_times(mgr, c2, add_times(mgr, x1, x2)),\n            add_times(mgr, c3, x1)),\n        add_times(mgr, c4, x2)),\n    c5)","category":"page"},{"location":"guide/adds/#Subtraction","page":"Algebraic Decision Diagrams (ADDs)","title":"Subtraction","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(2)\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\n\n# f(x1, x2) = x1 - x2\nf = add_minus(mgr, x1, x2)\n\n# Can be negative: returns -1 if x1=0, x2=1","category":"page"},{"location":"guide/adds/#Division","page":"Algebraic Decision Diagrams (ADDs)","title":"Division","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(2)\nx1 = add_ith_var(mgr, 1)\nc2 = add_const(mgr, 2.0)\n\n# f(x1) = x1 / 2\nf = add_divide(mgr, x1, c2)\n\n# Note: Division by zero returns infinity","category":"page"},{"location":"guide/adds/#Min/Max-Operations","page":"Algebraic Decision Diagrams (ADDs)","title":"Min/Max Operations","text":"","category":"section"},{"location":"guide/adds/#Minimum","page":"Algebraic Decision Diagrams (ADDs)","title":"Minimum","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(2)\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\n\n# f(x1, x2) = min(x1, x2)\nf = add_min(mgr, x1, x2)\n\n# With constants: g(x1, x2) = min(5, 3*x1 + 2*x2)\nc5 = add_const(mgr, 5.0)\nc3 = add_const(mgr, 3.0)\nc2 = add_const(mgr, 2.0)\n\nexpr = add_plus(mgr, add_times(mgr, c3, x1), add_times(mgr, c2, x2))\ng = add_min(mgr, c5, expr)","category":"page"},{"location":"guide/adds/#Maximum","page":"Algebraic Decision Diagrams (ADDs)","title":"Maximum","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(2)\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\n\n# f(x1, x2) = max(x1, x2)\nf = add_max(mgr, x1, x2)\n\n# Clamping: g(x) = max(0, min(x, 1))\nc0 = add_const(mgr, 0.0)\nc1 = add_const(mgr, 1.0)\ng = add_max(mgr, c0, add_min(mgr, x1, c1))","category":"page"},{"location":"guide/adds/#Evaluation","page":"Algebraic Decision Diagrams (ADDs)","title":"Evaluation","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"Evaluate an ADD with specific variable assignments:","category":"page"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(3)\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\nx3 = add_ith_var(mgr, 3)\n\n# f(x1, x2, x3) = 2*x1 + 3*x2 + 4*x3\nc2 = add_const(mgr, 2.0)\nc3 = add_const(mgr, 3.0)\nc4 = add_const(mgr, 4.0)\n\nf = add_plus(mgr,\n    add_plus(mgr,\n        add_times(mgr, c2, x1),\n        add_times(mgr, c3, x2)),\n    add_times(mgr, c4, x3))\n\n# Evaluate with x1=1, x2=1, x3=1\nassignment = Dict(1 => 1.0, 2 => 1.0, 3 => 1.0)\nresult = add_eval(mgr, f, assignment)  # 9.0\n\n# Evaluate with x1=1, x2=0, x3=1\nassignment = Dict(1 => 1.0, 2 => 0.0, 3 => 1.0)\nresult = add_eval(mgr, f, assignment)  # 6.0\n\n# Evaluate with x1=0, x2=0, x3=0\nassignment = Dict(1 => 0.0, 2 => 0.0, 3 => 0.0)\nresult = add_eval(mgr, f, assignment)  # 0.0","category":"page"},{"location":"guide/adds/#Converting-Between-BDDs-and-ADDs","page":"Algebraic Decision Diagrams (ADDs)","title":"Converting Between BDDs and ADDs","text":"","category":"section"},{"location":"guide/adds/#BDD-to-ADD","page":"Algebraic Decision Diagrams (ADDs)","title":"BDD to ADD","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"Convert a BDD to an ADD (0-1 function):","category":"page"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(2)\n\n# Create BDD\nx1_bdd = ith_var(mgr, 1)\nx2_bdd = ith_var(mgr, 2)\nf_bdd = bdd_and(mgr, x1_bdd, x2_bdd)\n\n# Convert to ADD\nf_add = bdd_to_add(mgr, f_bdd)\n\n# Now can use arithmetic operations\nc2 = add_const(mgr, 2.0)\ng = add_times(mgr, c2, f_add)  # 2 if both true, 0 otherwise","category":"page"},{"location":"guide/adds/#ADD-to-BDD","page":"Algebraic Decision Diagrams (ADDs)","title":"ADD to BDD","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"Convert an ADD to a BDD (threshold operation):","category":"page"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(2)\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\n\n# f(x1, x2) = x1 + x2\nf = add_plus(mgr, x1, x2)\n\n# Convert to BDD: true if f > 0\nf_bdd = add_to_bdd(mgr, f)\n\n# This is equivalent to x1 ∨ x2\nx1_bdd = ith_var(mgr, 1)\nx2_bdd = ith_var(mgr, 2)\nexpected = bdd_or(mgr, x1_bdd, x2_bdd)\n@assert f_bdd == expected","category":"page"},{"location":"guide/adds/#Applications","page":"Algebraic Decision Diagrams (ADDs)","title":"Applications","text":"","category":"section"},{"location":"guide/adds/#Probability-Calculations","page":"Algebraic Decision Diagrams (ADDs)","title":"Probability Calculations","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(3)\n\n# Independent events with probabilities\n# P(A) = 0.7, P(B) = 0.5, P(C) = 0.3\np_a = add_const(mgr, 0.7)\np_b = add_const(mgr, 0.5)\np_c = add_const(mgr, 0.3)\n\n# Complement probabilities\np_not_a = add_const(mgr, 0.3)\np_not_b = add_const(mgr, 0.5)\np_not_c = add_const(mgr, 0.7)\n\n# Variables\na = add_ith_var(mgr, 1)\nb = add_ith_var(mgr, 2)\nc = add_ith_var(mgr, 3)\n\n# P(A ∧ B ∧ C) = P(A) * P(B) * P(C)\n# Build probability function\nprob_a = add_plus(mgr,\n    add_times(mgr, a, p_a),\n    add_times(mgr, add_minus(mgr, add_const(mgr, 1.0), a), p_not_a))\n\nprob_b = add_plus(mgr,\n    add_times(mgr, b, p_b),\n    add_times(mgr, add_minus(mgr, add_const(mgr, 1.0), b), p_not_b))\n\nprob_c = add_plus(mgr,\n    add_times(mgr, c, p_c),\n    add_times(mgr, add_minus(mgr, add_const(mgr, 1.0), c), p_not_c))\n\n# Joint probability\njoint = add_times(mgr, add_times(mgr, prob_a, prob_b), prob_c)\n\n# Evaluate: P(A=true, B=true, C=true)\nassignment = Dict(1 => 1.0, 2 => 1.0, 3 => 1.0)\np_all_true = add_eval(mgr, joint, assignment)  # 0.105","category":"page"},{"location":"guide/adds/#Weighted-Counting","page":"Algebraic Decision Diagrams (ADDs)","title":"Weighted Counting","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(3)\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\nx3 = add_ith_var(mgr, 3)\n\n# Weights for each variable\nw1 = add_const(mgr, 2.0)\nw2 = add_const(mgr, 3.0)\nw3 = add_const(mgr, 5.0)\n\n# Total weight: 2*x1 + 3*x2 + 5*x3\ntotal_weight = add_plus(mgr,\n    add_plus(mgr,\n        add_times(mgr, w1, x1),\n        add_times(mgr, w2, x2)),\n    add_times(mgr, w3, x3))\n\n# Constraint: at least two variables must be true\nx1_bdd = ith_var(mgr, 1)\nx2_bdd = ith_var(mgr, 2)\nx3_bdd = ith_var(mgr, 3)\n\nat_least_two = bdd_or(mgr,\n    bdd_or(mgr,\n        bdd_and(mgr, x1_bdd, x2_bdd),\n        bdd_and(mgr, x1_bdd, x3_bdd)),\n    bdd_and(mgr, x2_bdd, x3_bdd))\n\n# Convert constraint to ADD\nconstraint_add = bdd_to_add(mgr, at_least_two)\n\n# Apply constraint: weight if constraint satisfied, 0 otherwise\nconstrained_weight = add_times(mgr, total_weight, constraint_add)\n\n# Find maximum weight satisfying constraint\n# (Would need to enumerate all assignments)","category":"page"},{"location":"guide/adds/#Optimization","page":"Algebraic Decision Diagrams (ADDs)","title":"Optimization","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(3)\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\nx3 = add_ith_var(mgr, 3)\n\n# Objective function: maximize 5*x1 + 3*x2 + 2*x3\nc5 = add_const(mgr, 5.0)\nc3 = add_const(mgr, 3.0)\nc2 = add_const(mgr, 2.0)\n\nobjective = add_plus(mgr,\n    add_plus(mgr,\n        add_times(mgr, c5, x1),\n        add_times(mgr, c3, x2)),\n    add_times(mgr, c2, x3))\n\n# Constraint: x1 + x2 + x3 <= 2\nsum_vars = add_plus(mgr, add_plus(mgr, x1, x2), x3)\nc2_const = add_const(mgr, 2.0)\n\n# Check all assignments to find maximum\nmax_value = -Inf\nbest_assignment = nothing\n\nfor x1_val in [0.0, 1.0]\n    for x2_val in [0.0, 1.0]\n        for x3_val in [0.0, 1.0]\n            assignment = Dict(1 => x1_val, 2 => x2_val, 3 => x3_val)\n\n            # Check constraint\n            sum_val = add_eval(mgr, sum_vars, assignment)\n            if sum_val <= 2.0\n                # Evaluate objective\n                obj_val = add_eval(mgr, objective, assignment)\n                if obj_val > max_value\n                    max_value = obj_val\n                    best_assignment = assignment\n                end\n            end\n        end\n    end\nend\n\nprintln(\"Maximum value: \", max_value)  # 10.0\nprintln(\"Best assignment: \", best_assignment)  # x1=1, x2=1, x3=0","category":"page"},{"location":"guide/adds/#Performance-Tips","page":"Algebraic Decision Diagrams (ADDs)","title":"Performance Tips","text":"","category":"section"},{"location":"guide/adds/#1.-Use-Constants-Efficiently","page":"Algebraic Decision Diagrams (ADDs)","title":"1. Use Constants Efficiently","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(10)\n\n# Good: Create constant once\nc2 = add_const(mgr, 2.0)\nresults = [add_times(mgr, c2, add_ith_var(mgr, i)) for i in 1:10]\n\n# Bad: Create constant repeatedly\nresults = [add_times(mgr, add_const(mgr, 2.0), add_ith_var(mgr, i)) for i in 1:10]","category":"page"},{"location":"guide/adds/#2.-Build-Incrementally","page":"Algebraic Decision Diagrams (ADDs)","title":"2. Build Incrementally","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(5)\nvars = [add_ith_var(mgr, i) for i in 1:5]\n\n# Good: Build incrementally\nresult = vars[1]\nfor i in 2:5\n    result = add_plus(mgr, result, vars[i])\nend\n\n# Also good: Use reduce\nresult = reduce((acc, v) -> add_plus(mgr, acc, v), vars)","category":"page"},{"location":"guide/adds/#3.-Avoid-Unnecessary-Conversions","page":"Algebraic Decision Diagrams (ADDs)","title":"3. Avoid Unnecessary Conversions","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(3)\n\n# Good: Work in ADD domain\nx1 = add_ith_var(mgr, 1)\nx2 = add_ith_var(mgr, 2)\nresult = add_plus(mgr, x1, x2)\n\n# Bad: Unnecessary conversions\nx1_bdd = ith_var(mgr, 1)\nx1_add = bdd_to_add(mgr, x1_bdd)  # Unnecessary","category":"page"},{"location":"guide/adds/#Limitations","page":"Algebraic Decision Diagrams (ADDs)","title":"Limitations","text":"","category":"section"},{"location":"guide/adds/#No-Complement-Edges","page":"Algebraic Decision Diagrams (ADDs)","title":"No Complement Edges","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"Unlike BDDs, ADDs don't use complement edges:","category":"page"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"Negation requires explicit computation\nMay result in larger diagrams\nBut allows arbitrary real values","category":"page"},{"location":"guide/adds/#Numerical-Precision","page":"Algebraic Decision Diagrams (ADDs)","title":"Numerical Precision","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"ADDs use floating-point arithmetic:","category":"page"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"Subject to rounding errors\nEquality comparisons may be inexact\nConsider using tolerance for comparisons","category":"page"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"mgr = DDManager(2)\nx = add_ith_var(mgr, 1)\n\n# May not be exactly equal due to floating point\nc1 = add_const(mgr, 0.1)\nc2 = add_const(mgr, 0.2)\nc3 = add_const(mgr, 0.3)\n\nsum = add_plus(mgr, c1, c2)\n# sum might not exactly equal c3 due to floating point","category":"page"},{"location":"guide/adds/#See-Also","page":"Algebraic Decision Diagrams (ADDs)","title":"See Also","text":"","category":"section"},{"location":"guide/adds/","page":"Algebraic Decision Diagrams (ADDs)","title":"Algebraic Decision Diagrams (ADDs)","text":"BDD Guide: Binary Decision Diagrams\nZDD Guide: Zero-suppressed Decision Diagrams\nAPI Reference: Complete API documentation","category":"page"}]
}
